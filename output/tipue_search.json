{
    "pages": [
        {
            "title": "Arboles de Decisiones", 
            "text":"/*! * * IPython notebook * */ /* CSS font colors for translated ANSI escape sequences */ /* The color values are a mix of http://www.xcolors.net/dl/baskerville-ivorylight and http://www.xcolors.net/dl/euphrasia */ .ansi-black-fg { color: #3E424D; } .ansi-black-bg { background-color: #3E424D; } .ansi-black-intense-fg { color: #282C36; } .ansi-black-intense-bg { background-color: #282C36; } .ansi-red-fg { color: #E75C58; } .ansi-red-bg { background-color: #E75C58; } .ansi-red-intense-fg { color: #B22B31; } .ansi-red-intense-bg { background-color: #B22B31; } .ansi-green-fg { color: #00A250; } .ansi-green-bg { background-color: #00A250; } .ansi-green-intense-fg { color: #007427; } .ansi-green-intense-bg { background-color: #007427; } .ansi-yellow-fg { color: #DDB62B; } .ansi-yellow-bg { background-color: #DDB62B; } .ansi-yellow-intense-fg { color: #B27D12; } .ansi-yellow-intense-bg { background-color: #B27D12; } .ansi-blue-fg { color: #208FFB; } .ansi-blue-bg { background-color: #208FFB; } .ansi-blue-intense-fg { color: #0065CA; } .ansi-blue-intense-bg { background-color: #0065CA; } .ansi-magenta-fg { color: #D160C4; } .ansi-magenta-bg { background-color: #D160C4; } .ansi-magenta-intense-fg { color: #A03196; } .ansi-magenta-intense-bg { background-color: #A03196; } .ansi-cyan-fg { color: #60C6C8; } .ansi-cyan-bg { background-color: #60C6C8; } .ansi-cyan-intense-fg { color: #258F8F; } .ansi-cyan-intense-bg { background-color: #258F8F; } .ansi-white-fg { color: #C5C1B4; } .ansi-white-bg { background-color: #C5C1B4; } .ansi-white-intense-fg { color: #A1A6B2; } .ansi-white-intense-bg { background-color: #A1A6B2; } .ansi-default-inverse-fg { color: #FFFFFF; } .ansi-default-inverse-bg { background-color: #000000; } .ansi-bold { font-weight: bold; } .ansi-underline { text-decoration: underline; } /* The following styles are deprecated an will be removed in a future version */ .ansibold { font-weight: bold; } .ansi-inverse { outline: 0.5px dotted; } /* use dark versions for foreground, to improve visibility */ .ansiblack { color: black; } .ansired { color: darkred; } .ansigreen { color: darkgreen; } .ansiyellow { color: #c4a000; } .ansiblue { color: darkblue; } .ansipurple { color: darkviolet; } .ansicyan { color: steelblue; } .ansigray { color: gray; } /* and light for background, for the same reason */ .ansibgblack { background-color: black; } .ansibgred { background-color: red; } .ansibggreen { background-color: green; } .ansibgyellow { background-color: yellow; } .ansibgblue { background-color: blue; } .ansibgpurple { background-color: magenta; } .ansibgcyan { background-color: cyan; } .ansibggray { background-color: gray; } div.cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; border-radius: 2px; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; border-width: 1px; border-style: solid; border-color: transparent; width: 100%; padding: 5px; /* This acts as a spacer between cells, that is outside the border */ margin: 0px; outline: none; position: relative; overflow: visible; } div.cell:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: &#39;&#39;; background: transparent; } div.cell.jupyter-soft-selected { border-left-color: #E3F2FD; border-left-width: 1px; padding-left: 5px; border-right-color: #E3F2FD; border-right-width: 1px; background: #E3F2FD; } @media print { div.cell.jupyter-soft-selected { border-color: transparent; } } div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: #ababab; } div.cell.selected:before, div.cell.selected.jupyter-soft-selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: &#39;&#39;; background: #42A5F5; } @media print { div.cell.selected, div.cell.selected.jupyter-soft-selected { border-color: transparent; } } .edit_mode div.cell.selected { border-color: #66BB6A; } .edit_mode div.cell.selected:before { position: absolute; display: block; top: -1px; left: -1px; width: 5px; height: calc(100% + 2px); content: &#39;&#39;; background: #66BB6A; } @media print { .edit_mode div.cell.selected { border-color: transparent; } } .prompt { /* This needs to be wide enough for 3 digit prompt numbers: In[100]: */ min-width: 14ex; /* This padding is tuned to match the padding on the CodeMirror editor. */ padding: 0.4em; margin: 0px; font-family: monospace; text-align: right; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; /* Don&#39;t highlight prompt number selection */ -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; /* Use default cursor */ cursor: default; } @media (max-width: 540px) { .prompt { text-align: left; } } div.inner_cell { min-width: 0; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_area { border: 1px solid #cfcfcf; border-radius: 2px; background: #f7f7f7; line-height: 1.21429em; } /* This is needed so that empty prompt areas can collapse to zero height when there is no content in the output_subarea and the prompt. The main purpose of this is to make sure that empty JavaScript output_subareas have no height. */ div.prompt:empty { padding-top: 0; padding-bottom: 0; } div.unrecognized_cell { padding: 5px 5px 5px 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.unrecognized_cell .inner_cell { border-radius: 2px; padding: 5px; font-weight: bold; color: red; border: 1px solid #cfcfcf; background: #eaeaea; } div.unrecognized_cell .inner_cell a { color: inherit; text-decoration: none; } div.unrecognized_cell .inner_cell a:hover { color: inherit; text-decoration: none; } @media (max-width: 540px) { div.unrecognized_cell &gt; div.prompt { display: none; } } div.code_cell { /* avoid page breaking on code cells when printing */ } @media print { div.code_cell { page-break-inside: avoid; } } /* any special styling for code cells that are currently running goes here */ div.input { page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.input { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } /* input_area and input_prompt must match in top border and margin for alignment */ div.input_prompt { color: #303F9F; border-top: 1px solid transparent; } div.input_area &gt; div.highlight { margin: 0.4em; border: none; padding: 0px; background-color: transparent; } div.input_area &gt; div.highlight &gt; pre { margin: 0px; border: none; padding: 0px; background-color: transparent; } /* The following gets added to the if it is detected that the user has a * monospace font with inconsistent normal/bold/italic height. See * notebookmain.js. Such fonts will have keywords vertically offset with * respect to the rest of the text. The user should select a better font. * See: https://github.com/ipython/ipython/issues/1503 * * .CodeMirror span { * vertical-align: bottom; * } */ .CodeMirror { line-height: 1.21429em; /* Changed from 1em to our global default */ font-size: 14px; height: auto; /* Changed to auto to autogrow */ background: none; /* Changed from white to allow our bg to show through */ } .CodeMirror-scroll { /* The CodeMirror docs are a bit fuzzy on if overflow-y should be hidden or visible.*/ /* We have found that if it is visible, vertical scrollbars appear with font size changes.*/ overflow-y: hidden; overflow-x: auto; } .CodeMirror-lines { /* In CM2, this used to be 0.4em, but in CM3 it went to 4px. We need the em value because */ /* we have set a different line-height and want this to scale with that. */ /* Note that this should set vertical padding only, since CodeMirror assumes that horizontal padding will be set on CodeMirror pre */ padding: 0.4em 0; } .CodeMirror-linenumber { padding: 0 8px 0 4px; } .CodeMirror-gutters { border-bottom-left-radius: 2px; border-top-left-radius: 2px; } .CodeMirror pre { /* In CM3 this went to 4px from 0 in CM2. This sets horizontal padding only, use .CodeMirror-lines for vertical */ padding: 0 0.4em; border: 0; border-radius: 0; } .CodeMirror-cursor { border-left: 1.4px solid black; } @media screen and (min-width: 2138px) and (max-width: 4319px) { .CodeMirror-cursor { border-left: 2px solid black; } } @media screen and (min-width: 4320px) { .CodeMirror-cursor { border-left: 4px solid black; } } /* Original style from softwaremaniacs.org (c) Ivan Sagalaev Adapted from GitHub theme */ .highlight-base { color: #000; } .highlight-variable { color: #000; } .highlight-variable-2 { color: #1a1a1a; } .highlight-variable-3 { color: #333333; } .highlight-string { color: #BA2121; } .highlight-comment { color: #408080; font-style: italic; } .highlight-number { color: #080; } .highlight-atom { color: #88F; } .highlight-keyword { color: #008000; font-weight: bold; } .highlight-builtin { color: #008000; } .highlight-error { color: #f00; } .highlight-operator { color: #AA22FF; font-weight: bold; } .highlight-meta { color: #AA22FF; } /* previously not defined, copying from default codemirror */ .highlight-def { color: #00f; } .highlight-string-2 { color: #f50; } .highlight-qualifier { color: #555; } .highlight-bracket { color: #997; } .highlight-tag { color: #170; } .highlight-attribute { color: #00c; } .highlight-header { color: blue; } .highlight-quote { color: #090; } .highlight-link { color: #00c; } /* apply the same style to codemirror */ .cm-s-ipython span.cm-keyword { color: #008000; font-weight: bold; } .cm-s-ipython span.cm-atom { color: #88F; } .cm-s-ipython span.cm-number { color: #080; } .cm-s-ipython span.cm-def { color: #00f; } .cm-s-ipython span.cm-variable { color: #000; } .cm-s-ipython span.cm-operator { color: #AA22FF; font-weight: bold; } .cm-s-ipython span.cm-variable-2 { color: #1a1a1a; } .cm-s-ipython span.cm-variable-3 { color: #333333; } .cm-s-ipython span.cm-comment { color: #408080; font-style: italic; } .cm-s-ipython span.cm-string { color: #BA2121; } .cm-s-ipython span.cm-string-2 { color: #f50; } .cm-s-ipython span.cm-meta { color: #AA22FF; } .cm-s-ipython span.cm-qualifier { color: #555; } .cm-s-ipython span.cm-builtin { color: #008000; } .cm-s-ipython span.cm-bracket { color: #997; } .cm-s-ipython span.cm-tag { color: #170; } .cm-s-ipython span.cm-attribute { color: #00c; } .cm-s-ipython span.cm-header { color: blue; } .cm-s-ipython span.cm-quote { color: #090; } .cm-s-ipython span.cm-link { color: #00c; } .cm-s-ipython span.cm-error { color: #f00; } .cm-s-ipython span.cm-tab { background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAMCAYAAAAkuj5RAAAAAXNSR0IArs4c6QAAAGFJREFUSMft1LsRQFAQheHPowAKoACx3IgEKtaEHujDjORSgWTH/ZOdnZOcM/sgk/kFFWY0qV8foQwS4MKBCS3qR6ixBJvElOobYAtivseIE120FaowJPN75GMu8j/LfMwNjh4HUpwg4LUAAAAASUVORK5CYII=); background-position: right; background-repeat: no-repeat; } div.output_wrapper { /* this position must be relative to enable descendents to be absolute within it */ position: relative; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; z-index: 1; } /* class for the output area when it should be height-limited */ div.output_scroll { /* ideally, this would be max-height, but FF barfs all over that */ height: 24em; /* FF needs this *and the wrapper* to specify full width, or it will shrinkwrap */ width: 100%; overflow: auto; border-radius: 2px; -webkit-box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.8); display: block; } /* output div while it is collapsed */ div.output_collapsed { margin: 0px; padding: 0px; /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } div.out_prompt_overlay { height: 100%; padding: 0px 0.4em; position: absolute; border-radius: 2px; } div.out_prompt_overlay:hover { /* use inner shadow to get border that is computed the same on WebKit/FF */ -webkit-box-shadow: inset 0 0 1px #000; box-shadow: inset 0 0 1px #000; background: rgba(240, 240, 240, 0.5); } div.output_prompt { color: #D84315; } /* This class is the outer container of all output sections. */ div.output_area { padding: 0px; page-break-inside: avoid; /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } div.output_area .MathJax_Display { text-align: left !important; } div.output_area div.output_area div.output_area img, div.output_area svg { max-width: 100%; height: auto; } div.output_area img.unconfined, div.output_area svg.unconfined { max-width: none; } div.output_area .mglyph &gt; img { max-width: none; } /* This is needed to protect the pre formating from global settings such as that of bootstrap */ .output { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } @media (max-width: 540px) { div.output_area { /* Old browsers */ display: -webkit-box; -webkit-box-orient: vertical; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: vertical; -moz-box-align: stretch; display: box; box-orient: vertical; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: column; align-items: stretch; } } div.output_area pre { margin: 0; padding: 1px 0 1px 0; border: 0; vertical-align: baseline; color: black; background-color: transparent; border-radius: 0; } /* This class is for the output subarea inside the output_area and after the prompt div. */ div.output_subarea { overflow-x: auto; padding: 0.4em; /* Old browsers */ -webkit-box-flex: 1; -moz-box-flex: 1; box-flex: 1; /* Modern browsers */ flex: 1; max-width: calc(100% - 14ex); } div.output_scroll div.output_subarea { overflow-x: visible; } /* The rest of the output_* classes are for special styling of the different output types */ /* all text output has this class: */ div.output_text { text-align: left; color: #000; /* This has to match that of the the CodeMirror class line-height below */ line-height: 1.21429em; } /* stdout/stderr are &#39;text&#39; as well as &#39;stream&#39;, but execute_result/error are *not* streams */ div.output_stderr { background: #fdd; /* very light red background for stderr */ } div.output_latex { text-align: left; } /* Empty output_javascript divs should have no height */ div.output_javascript:empty { padding: 0; } .js-error { color: darkred; } /* raw_input styles */ div.raw_input_container { line-height: 1.21429em; padding-top: 5px; } pre.raw_input_prompt { /* nothing needed here. */ } input.raw_input { font-family: monospace; font-size: inherit; color: inherit; width: auto; /* make sure input baseline aligns with prompt */ vertical-align: baseline; /* padding + margin = 0.5em between prompt and cursor */ padding: 0em 0.25em; margin: 0em 0.25em; } input.raw_input:focus { box-shadow: none; } p.p-space { margin-bottom: 10px; } div.output_unrecognized { padding: 5px; font-weight: bold; color: red; } div.output_unrecognized a { color: inherit; text-decoration: none; } div.output_unrecognized a:hover { color: inherit; text-decoration: none; } .rendered_html { color: #000; /* any extras will just be numbers: */ } .rendered_html :link { text-decoration: underline; } .rendered_html :visited { text-decoration: underline; } .rendered_html h1:first-child { margin-top: 0.538em; } .rendered_html h2:first-child { margin-top: 0.636em; } .rendered_html h3:first-child { margin-top: 0.777em; } .rendered_html h4:first-child { margin-top: 1em; } .rendered_html h5:first-child { margin-top: 1em; } .rendered_html h6:first-child { margin-top: 1em; } .rendered_html ul:not(.list-inline), .rendered_html ol:not(.list-inline) { padding-left: 2em; } .rendered_html * + ul { margin-top: 1em; } .rendered_html * + ol { margin-top: 1em; } .rendered_html pre, .rendered_html tr, .rendered_html th, .rendered_html tbody tr:nth-child(odd) { background: #f5f5f5; } .rendered_html tbody tr:hover { background: rgba(66, 165, 245, 0.2); } .rendered_html * + table { margin-top: 1em; } .rendered_html * + p { margin-top: 1em; } .rendered_html * + img { margin-top: 1em; } .rendered_html img, .rendered_html img.unconfined, .rendered_html * + .alert { margin-top: 1em; } [dir=&#34;rtl&#34;] div.text_cell { /* Old browsers */ display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-align: stretch; display: -moz-box; -moz-box-orient: horizontal; -moz-box-align: stretch; display: box; box-orient: horizontal; box-align: stretch; /* Modern browsers */ display: flex; flex-direction: row; align-items: stretch; } @media (max-width: 540px) { div.text_cell &gt; div.prompt { display: none; } } div.text_cell_render { /*font-family: &#34;Helvetica Neue&#34;, Arial, Helvetica, Geneva, sans-serif;*/ outline: none; resize: none; width: inherit; border-style: none; padding: 0.5em 0.5em 0.5em 0.4em; color: #000; box-sizing: border-box; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; } a.anchor-link:link { text-decoration: none; padding: 0px 20px; visibility: hidden; } h1:hover .anchor-link, h2:hover .anchor-link, h3:hover .anchor-link, h4:hover .anchor-link, h5:hover .anchor-link, h6:hover .anchor-link { visibility: visible; } .text_cell.rendered .input_area { display: none; } .text_cell.rendered .text_cell.rendered .rendered_html tr, .text_cell.rendered .rendered_html th, .text_cell.rendered .text_cell.unrendered .text_cell_render { display: none; } .text_cell .dropzone .input_area { border: 2px dashed #bababa; margin: -1px; } .cm-header-1, .cm-header-2, .cm-header-3, .cm-header-4, .cm-header-5, .cm-header-6 { font-weight: bold; font-family: &#34;Helvetica Neue&#34;, Helvetica, Arial, sans-serif; } .cm-header-1 { font-size: 185.7%; } .cm-header-2 { font-size: 157.1%; } .cm-header-3 { font-size: 128.6%; } .cm-header-4 { font-size: 110%; } .cm-header-5 { font-size: 100%; font-style: italic; } .cm-header-6 { font-size: 100%; font-style: italic; } .highlight .hll { background-color: #ffffcc } .highlight { background: #f8f8f8; } .highlight .c { color: #408080; font-style: italic } /* Comment */ .highlight .err { border: 1px solid #FF0000 } /* Error */ .highlight .k { color: #008000; font-weight: bold } /* Keyword */ .highlight .o { color: #666666 } /* Operator */ .highlight .ch { color: #408080; font-style: italic } /* Comment.Hashbang */ .highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */ .highlight .cp { color: #BC7A00 } /* Comment.Preproc */ .highlight .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */ .highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */ .highlight .cs { color: #408080; font-style: italic } /* Comment.Special */ .highlight .gd { color: #A00000 } /* Generic.Deleted */ .highlight .ge { font-style: italic } /* Generic.Emph */ .highlight .gr { color: #FF0000 } /* Generic.Error */ .highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */ .highlight .gi { color: #00A000 } /* Generic.Inserted */ .highlight .go { color: #888888 } /* Generic.Output */ .highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */ .highlight .gs { font-weight: bold } /* Generic.Strong */ .highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */ .highlight .gt { color: #0044DD } /* Generic.Traceback */ .highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */ .highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */ .highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */ .highlight .kp { color: #008000 } /* Keyword.Pseudo */ .highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */ .highlight .kt { color: #B00040 } /* Keyword.Type */ .highlight .m { color: #666666 } /* Literal.Number */ .highlight .s { color: #BA2121 } /* Literal.String */ .highlight .na { color: #7D9029 } /* Name.Attribute */ .highlight .nb { color: #008000 } /* Name.Builtin */ .highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */ .highlight .no { color: #880000 } /* Name.Constant */ .highlight .nd { color: #AA22FF } /* Name.Decorator */ .highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */ .highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */ .highlight .nf { color: #0000FF } /* Name.Function */ .highlight .nl { color: #A0A000 } /* Name.Label */ .highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */ .highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */ .highlight .nv { color: #19177C } /* Name.Variable */ .highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */ .highlight .w { color: #bbbbbb } /* Text.Whitespace */ .highlight .mb { color: #666666 } /* Literal.Number.Bin */ .highlight .mf { color: #666666 } /* Literal.Number.Float */ .highlight .mh { color: #666666 } /* Literal.Number.Hex */ .highlight .mi { color: #666666 } /* Literal.Number.Integer */ .highlight .mo { color: #666666 } /* Literal.Number.Oct */ .highlight .sa { color: #BA2121 } /* Literal.String.Affix */ .highlight .sb { color: #BA2121 } /* Literal.String.Backtick */ .highlight .sc { color: #BA2121 } /* Literal.String.Char */ .highlight .dl { color: #BA2121 } /* Literal.String.Delimiter */ .highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */ .highlight .s2 { color: #BA2121 } /* Literal.String.Double */ .highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */ .highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */ .highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */ .highlight .sx { color: #008000 } /* Literal.String.Other */ .highlight .sr { color: #BB6688 } /* Literal.String.Regex */ .highlight .s1 { color: #BA2121 } /* Literal.String.Single */ .highlight .ss { color: #19177C } /* Literal.String.Symbol */ .highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */ .highlight .fm { color: #0000FF } /* Name.Function.Magic */ .highlight .vc { color: #19177C } /* Name.Variable.Class */ .highlight .vg { color: #19177C } /* Name.Variable.Global */ .highlight .vi { color: #19177C } /* Name.Variable.Instance */ .highlight .vm { color: #19177C } /* Name.Variable.Magic */ .highlight .il { color: #666666 } /* Literal.Number.Integer.Long */ DescripcionData Exploration: Es sobre descubrir que es lo que nuestros datos significan estadisticamente y aplicar tecnicas de visualizacion, este paso ser realiza para obtener aspectos importantes del conjunto. Univariado: Se enfoca en el analisis de los atributos uno a uno. Bivariado: Analisa dos atributos en conjunto Si quieres ir directamente a la teoria del arbol de decisiones Go to Aqui! In [1]: #Importacion de librerias import pandas as pd import seaborn as sns import numpy as np import matplotlib.pyplot as plt In [2]: #Cargar los datos data= pd.read_csv(&#34;golf-dataset.csv&#34;) In [3]: data Out[3]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Outlook Temp Humidity Windy Play Golf 0 Overcast Cool Normal True Yes 1 Overcast Hot High False Yes 2 Overcast Hot Normal False Yes 3 Overcast Mild High True Yes 4 Rainy Cool Normal False Yes 5 Rainy Cool Normal True No 6 Rainy Mild High False Yes 7 Rainy Mild High True No 8 Rainy Mild Normal False Yes 9 Sunny Cool Normal False Yes 10 Sunny Hot High False No 11 Sunny Hot High True No 12 Sunny Mild High False No 13 Sunny Mild Normal True Yes In [4]: #Exploracion de variables para determinar que son, numericas o categoricas data.dtypes Out[4]: Outlook object Temp object Humidity object Windy bool Play Golf object dtype: object In [5]: #Exploracion de variables para determinar si nos enfretamos con registros nulos data.info() &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 14 entries, 0 to 13 Data columns (total 5 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Outlook 14 non-null object 1 Temp 14 non-null object 2 Humidity 14 non-null object 3 Windy 14 non-null bool 4 Play Golf 14 non-null object dtypes: bool(1), object(4) memory usage: 590.0+ bytes In [6]: #**Exploracion de variables para determinar si nos enfretamos Problemas atipicos y grandes desviaciones** data.describe(include=&#34;all&#34;) Out[6]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Outlook Temp Humidity Windy Play Golf count 14 14 14 14 14 unique 3 3 2 2 2 top Sunny Mild Normal False Yes freq 5 6 7 8 9 Analisis UnivariadoParte del analisis univariado incluye realizar tablas de frecuencia para observar que tan recurrentes son las categorias. Como son atributos categoricos lo unico que podemos hacer es generar graficos pie o bar y tablas de frecuencia. Para realizar la tabla, creo un nuevo dataframe llamado outlook, mediante el metodo group by que agrupa los datos creando un nuevo indice en este caso sera el atributo outlook, mediante agg creamos una nueva columna que almacena el conteo de los atributos. In [7]: outlook=data.groupby(&#34;Outlook&#34;).agg(Frecuencia=(&#34;Outlook&#34;,&#34;count&#34;)) outlook[&#34;Frecuencia Acumulada&#34;]= outlook[&#34;Frecuencia&#34;].cumsum() outlook[&#34;Frecuencia Relativa&#34;]=outlook[&#34;Frecuencia&#34;]/14 outlook Out[7]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Frecuencia Frecuencia Acumulada Frecuencia Relativa Outlook Overcast 4 4 0.285714 Rainy 5 9 0.357143 Sunny 5 14 0.357143 In [41]: plt.subplots(figsize=(15,15)) sns.set_palette(&#34;hls&#34;, 8) plt.subplot(2,2,1) ax=data[&#34;Outlook&#34;].value_counts().plot.pie(legend=True,autopct=&#34;%1.1f%%&#34;) ax.set(title=&#34;Outlook&#34;,ylabel=&#34;&#34;) plt.subplot(2,2,2) sns.countplot(x=data[&#34;Outlook&#34;]) Out[41]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f38bd8c5b38&gt; *{stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:100000;} In [48]: temp = data.groupby(&#34;Temp&#34;).agg(Frecuencia=(&#34;Temp&#34;,&#34;count&#34;)) temp[&#34;Frecuencia Absoluta&#34;]= temp[&#34;Frecuencia&#34;].cumsum() temp[&#34;Frecuencia Relativa % &#34;]=round((temp[&#34;Frecuencia&#34;]/14)*100,2) temp Out[48]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Frecuencia Frecuencia Absoluta Frecuencia Relativa % Temp Cool 4 4 28.57 Hot 4 8 28.57 Mild 6 14 42.86 In [51]: plt.subplots(figsize=(10,10)) plt.subplot(2,2,1) #Fila,columna, indice data[&#34;Temp&#34;].value_counts().plot.pie(legend=True,autopct=&#34;%1.1f%%&#34;) plt.subplot(2,2,2) sns.countplot(data[&#34;Temp&#34;]) Out[51]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f38bd547d30&gt; *{stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:100000;} In [54]: humidity = data.groupby(&#34;Humidity&#34;).agg(Frecuencia=(&#34;Humidity&#34;,&#34;count&#34;)) humidity[&#34;Frecuencia Absotula&#34;]=humidity[&#34;Frecuencia&#34;].cumsum() humidity[&#34;Frecuencia Relativa&#34;]=round((humidity[&#34;Frecuencia&#34;]/14)*100,2) humidity Out[54]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Frecuencia Frecuencia Absotula Frecuencia Relativa Humidity High 7 7 50.0 Normal 7 14 50.0 In [57]: plt.subplots(figsize=(10,10)) plt.subplot(2,2,1) #Fila,columna, indice data[&#34;Humidity&#34;].value_counts().plot.pie(legend=True,autopct=&#34;%1.1f%%&#34;) plt.subplot(2,2,2) sns.countplot(data[&#34;Humidity&#34;]) Out[57]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f38bd51bac8&gt; *{stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:100000;} In [60]: windy=data.groupby(&#34;Windy&#34;).agg(Frecuencia=(&#34;Windy&#34;,&#34;count&#34;)) windy[&#34;Frecuencia Absoluta&#34;]= windy[&#34;Frecuencia&#34;].cumsum() windy[&#34;Frecuencia Relativa&#34;]=round((windy[&#34;Frecuencia&#34;]/14)*100,2) windy Out[60]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Frecuencia Frecuencia Absoluta Frecuencia Relativa Windy False 8 8 57.14 True 6 14 42.86 In [63]: plt.figure(figsize=(10,10)) plt.subplot(2,2,1) windy[&#34;Frecuencia&#34;].plot.pie(legend=True,autopct=&#34;%1.1f%%&#34;) plt.subplot(2,2,2) sns.barplot(windy.index,windy[&#34;Frecuencia&#34;]) Out[63]: &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f38bcf573c8&gt; *{stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:100000;} Analisis Bivariado Consiste en el analisis simultaneo de dos variables, explora el concepto de relacion entre las variables (predictor vs target), Existen tres tipos de analisis Bivariado Numerico &amp; Numerico Categorico &amp; Categorico Numerico &amp; Categorico En el caso de mi dataset es categorico vs categorico, lo que esta compuesto por graficos de barras y el test de chi cuadrado. Para este tipo de analisis chi cuadrado se generan dos hipotesis: hipotesis nula : jugar o no jugar *No* depende del outlook/ wind / humidity/ temp hipotesis alternativa : jugar o no jugar depende del outlook/ wind / humidity/ temp In [66]: pd.crosstab(data[&#34;Outlook&#34;],data[&#34;Play Golf&#34;],margins=True) Out[66]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Play Golf No Yes All Outlook Overcast 0 4 4 Rainy 2 3 5 Sunny 3 2 5 All 5 9 14 In [69]: plt.figure(figsize=(5,5)) g = sns.countplot(x=&#34;Temp&#34;,data=data,hue=&#34;Play Golf&#34;) *{stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:100000;} In [72]: g = sns.countplot(x=&#34;Outlook&#34;,data=data,hue=&#34;Play Golf&#34;) *{stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:100000;} In [75]: g = sns.countplot(x=&#34;Humidity&#34;,data=data,hue=&#34;Play Golf&#34;) *{stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:100000;} In [78]: g = sns.countplot(x=&#34;Windy&#34;,data=data,hue=&#34;Play Golf&#34;) *{stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:100000;} Test de chi2 para determinar la asociacion entre los atributos(Categoria)Manualmente chicuadrado se calcula con tres pasos: Definir las hipotesis --&gt; listo Construir Tabla de Contingencia Calcular valor de chi cuadrado Tabla de Contingencia La tabla de contingencia se construye con la siguiente formula $E = n * P$ n: Cantidad de elementos en el subconjunto P: Probabilidad la tabla de contingencia se construye en base a la tabla de observados de la siguiente manera: In [81]: observado = pd.crosstab(data[&#34;Outlook&#34;],data[&#34;Play Golf&#34;],margins=True) print(observado) #e1 = 14*((observado[&#34;All&#34;][&#34;Overcast&#34;]/14 )*(observado[&#34;Yes&#34;][&#34;All&#34;]/14)) Play Golf No Yes All Outlook Overcast 0 4 4 Rainy 2 3 5 Sunny 3 2 5 All 5 9 14 La tabla de contigencia se construye de la siguiente manera: Tabla de contigencia Play Golf No Yes Overcast E1 = 14 x p(overcast|no) = 14 * p(overcast)* p(no) = 14 * (4/14)* (5/14) = 1.42 E2 = 14 x p(overcast|yes) = 14 * p(overcast)* p(yes) = 14 * (4/14)* (9/14) = 2.57 Rainy E3 = 14 x p(rainy|no) = 14 * p(rainy)* p(no) = 14 * (5/14)* (5/14) = 1.78 E4 = 14 x p(rainy|yes) = 14 * p(rainy)* p(yes) = 14 * (5/14)* (9/14) = 3.12 Sunny E5 = 14 x p(sunny|no) = 14 * p(sunny)* p(no) = 14 * (5/14)* (5/14) = 1.78 E6 = 14 x p(sunny|yes) = 14 * p(sunny)* p(no) = 14 * (5/14)* (9/14) = 3.12 Calcular Chi cuadrado$\sum{(E-O)**2/E}$ overcast|no = (0- E1)** 2/E1 = (0-1.42)** 2/1.42 = 2.86 overcast|yes = (4 - 2.57)**2/2.57= 5.25 rainy|no =(2-1.78)**2/1.78 = 0.086 rainy|yes=(3-3.12)**2/3.12 = 0.044 sunny|no=(3-1.78)**2/1.78=2.64 sunny|yes=(2-3.12)**2/3.12=3.91 $\sum{(E-O)**2/E}$ = 14.79 Teniendo en consideracion un alpha de 0.05 ; $df = (nºfilas-1)(nºcolumnas-1)$ df=3-1 * 2-1 = 2 busco el valor en la tabla de chi cuadrado Link Tabla chi=5.99 como el corte de la region es en el punto 5.99 el valor 14.79 cae fuera de la region de aceptacion de h0 entonces aceptamos la hiptesis alternativa que indica que existe relacion entre el target y outlook. Scipy proporciona un metodo que realiza esto y es de la siguiente manera In [84]: from scipy.stats import chi2_contingency observado = pd.crosstab(data[&#34;Outlook&#34;],data[&#34;Play Golf&#34;]) chi,pvalue,df,expected= chi2_contingency(observado) print(&#34;Outlook vs Play Golf\n&#34;) print(&#34;valor de chi cuadrado :&#34;,chi) print(&#34;valor p o punto de corte:&#34;,pvalue) print(&#34;grados de libertad:&#34;,df) print(&#34;&#34;) print(&#34;Tabla de contingencia\n&#34;,expected) Outlook vs Play Golf valor de chi cuadrado : 3.5466666666666664 valor p o punto de corte: 0.16976615743981122 grados de libertad: 2 Tabla de contingencia [[1.42857143 2.57142857] [1.78571429 3.21428571] [1.78571429 3.21428571]] In [87]: observado = pd.crosstab(data[&#34;Temp&#34;],data[&#34;Play Golf&#34;]) chi,pvalue,df,expected= chi2_contingency(observado) print(&#34;Temp vs Play Golf\n&#34;) print(&#34;valor de chi cuadrado :&#34;,chi) print(&#34;valor p o punto de corte:&#34;,pvalue) print(&#34;grados de libertad:&#34;,df) print(&#34;&#34;) print(&#34;Tabla de contingencia\n&#34;,expected) Temp vs Play Golf valor de chi cuadrado : 0.5703703703703703 valor p o punto de corte: 0.7518750053142591 grados de libertad: 2 Tabla de contingencia [[1.42857143 2.57142857] [1.42857143 2.57142857] [2.14285714 3.85714286]] In [90]: observado = pd.crosstab(data[&#34;Humidity&#34;],data[&#34;Play Golf&#34;]) chi,pvalue,df,expected= chi2_contingency(observado) print(&#34;Humidity vs Play Golf\n&#34;) print(&#34;valor de chi cuadrado :&#34;,chi) print(&#34;valor p o punto de corte:&#34;,pvalue) Humidity vs Play Golf valor de chi cuadrado : 1.2444444444444445 valor p o punto de corte: 0.2646162170835855 In [93]: observado = pd.crosstab(data[&#34;Windy&#34;],data[&#34;Play Golf&#34;]) chi,pvalue,df,expected= chi2_contingency(observado) print(&#34;Windy vs Play Golf\n&#34;) print(&#34;valor de chi cuadrado :&#34;,chi) print(&#34;valor p o punto de corte:&#34;,pvalue) Windy vs Play Golf valor de chi cuadrado : 0.16203703703703703 valor p o punto de corte: 0.687287949348002 Resumen Outlook vs Play Golf Se acepta la Hipotesis Alternativa Temp vs Play Golf Se acepta la Hipotesis nula Humidity vs Play Golf Se acepta la Hipotesis alternativa Windy vs Play Gol Se acepta la Hipotesis nulaf Predecir el futuroEsta parte lo que hace es predicir el futuro mediante el modelamiento, como el target es categorico entonces nos enfrentamos a un problema de clasificacion si el target hubiese sido numerico entonces seria regression Arbol de decisionLos arboles de decision son modelos con estructura de arbol, el resultado final es un arbol con nodos de decision y nodos hoja. Existen varios algoritmos que permiten la construccion de un arbol de decisiones yo ocupare ID3 que emplea dos principales formulas matematicas Entropia y information gain. La entropia nos permite calcular la homogeneidad de la muestra, varia de o - 1, mientras mas cercano sea a 1 mas variado sera nuestro conjunto viceversa si es mas cercano a 0 sera mas homogeneo. Entropia del target. E(y) = $\sum{(-P(Ci)* (log(P(Ci))/log 2)}$ Entropia de los predictores. E(Y,x) = $\sum{(P(Ci)* E(Ci)}$ In [96]: #Entropia del target #Tabla auxiliar import math golf=data.groupby(&#34;Play Golf&#34;).agg(Frecuencia=(&#34;Play Golf&#34;,&#34;count&#34;)) golf E_golf = 0 for i in golf[&#34;Frecuencia&#34;]: E_golf=E_golf -i/14*math.log(i/14,2) print(&#34;Entropia Y = &#34;,round(E_golf,2)) #E_golf = -golf[&#34;Frecuencia&#34;]/14*math.log(golf[&#34;Frecuencia&#34;],2) Entropia Y = 0.94 In [143]: outlook=pd.crosstab(data[&#34;Outlook&#34;],data[&#34;Play Golf&#34;],margins=True) #E_golf_outlook = -outlook[&#34;All&#34;]/14 +(math.log(outlook[&#34;Yes&#34;]/outlook[&#34;All&#34;],2) + math.log(outlook[&#34;No&#34;]/outlook[&#34;All&#34;],2)) labels = set(list(data[&#34;Outlook&#34;])) def Entropia_pred(observados): E=0 aux=0 for i in labels: if observados[&#34;Yes&#34;][i]== 0: a = 0 else: a = math.log2(float(observados[&#34;Yes&#34;][i]/observados[&#34;All&#34;][i])) if observados[&#34;No&#34;][i] == 0: b = 0 else: b = math.log2(float(observados[&#34;No&#34;][i]/observados[&#34;All&#34;][i])) aux= (observados[&#34;All&#34;][i]/14) *((-observados[&#34;Yes&#34;][i]/observados[&#34;All&#34;][i] )* a-(observados[&#34;No&#34;][i]/observados[&#34;All&#34;][i])* b) E=E+aux print(&#34;Entropia de Outlook&#34;,E) Entropia_pred(outlook) Entropia de Outlook 0.6935361388961918 In [102]: temp=pd.crosstab(data[&#34;Temp&#34;],data[&#34;Play Golf&#34;],margins=True) labels = set(list(data[&#34;Temp&#34;])) Entropia_pred(temp) Entropia de Outlook 0.9110633930116763 In [105]: hum=pd.crosstab(data[&#34;Humidity&#34;],data[&#34;Play Golf&#34;],margins=True) labels = set(list(data[&#34;Humidity&#34;])) Entropia_pred(hum) Entropia de Outlook 0.7884504573082896 In [108]: wind=pd.crosstab(data[&#34;Windy&#34;],data[&#34;Play Golf&#34;],margins=True) labels = set(list(data[&#34;Windy&#34;])) Entropia_pred(wind) Entropia de Outlook 0.8921589282623617 Una vez calculadas las entropias se procede a calcular el gain $Information Gain(Y,x)=E(Y)-E(x)$ gain(play golf, Outlook)= E(Play Golf) - E(Play Golf,Outlook) = 0.94 - 0.69 = 0.25 gain(Play Golf,Temp) = 0.94 - 0.73 =0.21 gain(Play Golf, Humidity) = 0.94 - 0.788 =0.15 gain(Play Golf, Windy) = 0.94 - 0.89 =0.05 El gain mas alto corresponde al nodo raiz por ende sera Outlook, ahora filtramos la data por cada una de las categorias de outlook y las trabajamos a parte para encontrar el nodo que viene de la misma manera que lo habiamos hecho In [111]: filter =data[data[&#34;Outlook&#34;]==&#34;Sunny&#34;] temp=pd.crosstab(filter[&#34;Temp&#34;],filter[&#34;Play Golf&#34;],margins=True) labels = set(list(data[&#34;Temp&#34;])) Entropia_pred(temp) Entropia de Outlook 0.14285714285714285 In [114]: hum=pd.crosstab(filter[&#34;Humidity&#34;],filter[&#34;Play Golf&#34;],margins=True) labels = set(list(data[&#34;Humidity&#34;])) Entropia_pred(hum) Entropia de Outlook 0.0 In [117]: wind=pd.crosstab(filter[&#34;Windy&#34;],filter[&#34;Play Golf&#34;],margins=True) labels = set(list(data[&#34;Windy&#34;])) Entropia_pred(wind) Entropia de Outlook 0.3396348215831049 otra vez el gain para determinar que nodo se ubicara despues de outlook == Sunny gain(Play Gol outlook=Sunny,temp) =0.97 - 0.14 gain(Play Golf outlook=Sunny,Windy) = 0.97 - 0.33 gain(Play Golf outlook=Sunny,Humidity) = 0.97 - 0 = 0.97 Entonces el ganador es Humidity In [144]: filtro =data[data[&#34;Outlook&#34;]==&#34;Rainy&#34;] temp=pd.crosstab(filtro[&#34;Temp&#34;],filtro[&#34;Play Golf&#34;],margins=True) labels = set(list(filtro[&#34;Temp&#34;])) Entropia_pred(temp) Entropia de Outlook 0.3396348215831049 In [145]: filtro =data[data[&#34;Outlook&#34;]==&#34;Rainy&#34;] wind=pd.crosstab(filtro[&#34;Windy&#34;],filtro[&#34;Play Golf&#34;],margins=True) labels = set(list(filtro[&#34;Windy&#34;])) Entropia_pred(wind) Entropia de Outlook 0.0 Entonces calcular el gain seria: Gain(Play Golf Outlook =&#34;Rainy&#34;, Temp) = 0.97 - 0.95 Gain(Play Golf Outlook =&#34;Rainy&#34;, Windy) = 0.97 - 0 Dejamos como nodo Windy In [126]: outlook = pd.crosstab(data[&#34;Windy&#34;],data[&#34;Play Golf&#34;]) aux=[] for i in outlook.values: aux.append(i[0] + i[1]) In [129]: outlook[&#34;Frecuencia&#34;] = aux outlook Out[129]: .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Play Golf No Yes Frecuencia Windy False 2 6 8 True 3 3 6 if (!document.getElementById(&#39;mathjaxscript_pelican_#%@#$@#&#39;)) { var mathjaxscript = document.createElement(&#39;script&#39;); mathjaxscript.id = &#39;mathjaxscript_pelican_#%@#$@#&#39;; mathjaxscript.type = &#39;text/javascript&#39;; mathjaxscript.src = &#39;//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#39;; mathjaxscript[(window.opera ? &#34;innerHTML&#34; : &#34;text&#34;)] = &#34;MathJax.Hub.Config({&#34; + &#34; config: [&#39;MMLorHTML.js&#39;],&#34; + &#34; TeX: { extensions: [&#39;AMSmath.js&#39;,&#39;AMSsymbols.js&#39;,&#39;noErrors.js&#39;,&#39;noUndefined.js&#39;], equationNumbers: { autoNumber: &#39;AMS&#39; } },&#34; + &#34; jax: [&#39;input/TeX&#39;,&#39;input/MathML&#39;,&#39;output/HTML-CSS&#39;],&#34; + &#34; extensions: [&#39;tex2jax.js&#39;,&#39;mml2jax.js&#39;,&#39;MathMenu.js&#39;,&#39;MathZoom.js&#39;],&#34; + &#34; displayAlign: &#39;center&#39;,&#34; + &#34; displayIndent: &#39;0em&#39;,&#34; + &#34; showMathMenu: true,&#34; + &#34; tex2jax: { &#34; + &#34; inlineMath: [ [&#39;$&#39;,&#39;$&#39;] ], &#34; + &#34; displayMath: [ [&#39;$$&#39;,&#39;$$&#39;] ],&#34; + &#34; processEscapes: true,&#34; + &#34; preview: &#39;TeX&#39;,&#34; + &#34; }, &#34; + &#34; &#39;HTML-CSS&#39;: { &#34; + &#34; linebreaks: { automatic: true, width: &#39;95% container&#39; }, &#34; + &#34; styles: { &#39;.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn&#39;: {color: &#39;black ! important&#39;} }&#34; + &#34; } &#34; + &#34;}); &#34;; (document.body || document.getElementsByTagName(&#39;head&#39;)[0]).appendChild(mathjaxscript); }", 
            "tags": "posts", 
            "loc": "https://c3rssei.github.io/Blog/arboles-de-decisiones.html"
        },
        {
            "title": "Descubrir tu data (Conceptos)", 
            "text":"Descripcion Los datos estan construidos por data objects. un data object representa una entidad, en una base de datos medica, los objetos pueden ser pacientes, tambien se conocen como muestras, ejemplos, instancias o objetos. Por ende una fila de una base de datos corresponde a un data object. Referencias: Visualizaciones de datos con Python. https://www.ingeniovirtual.com/tipos-de-graficos-y-diagramas-para-la-visualizacion-de-datos/ https://infogram.com/es/pagina/elige-el-grafico-correcto-visualizacion-datos https://bookdown.org/aquintela/EBE/variables-continuas.html https://blog.adrianistan.eu/estadistica-python-pandas-numpy-scipy-parte-i Atributos Fuente de imagen. Un atributo es un campo de dato, que representa una caracteristica de una muestra, por ejemplo teniendo como muestra un cliente un posible atributo seria el nombre, telefono y asi... Atributos Nominales Nominal significa relativo a nombres, los valores de un atributo nominal son simbolos o nombres de cosas, cada valor representa algun tipo de categoria, por ejemplo el color de pelo, estado civil.. Los atributos nominales tambien pueden ser representados con numeros, por ejemplo el id de un respectivo cliente Atributos Ordinales Un atributo ordinal corresponde a un atributo con un posible sentido de orden o ranking, por ejemplo la talla de ropa que va de xs,s,m,l,xl .... Atributos Continuos Aquellos atributos que son continuos son aquellos que se pueden medir, como por ejemplo la temperatura, la humedad... La distribucion que siguen los atributos continuos pueden ser uniforme, normal, exponencial Atributos Discretos Los atributos discretos son aquellos que se pueden contar teniendo en cuenta un numero finito de cantidades, por ejemplo los años, cantidad de hijos... Medición de la tendencia central Medidas de tendencia central Grafico Fuente de imagen. Promedio la medida mas comun y efectiva para el centro de un conjunto de datos es el promedio. Lo cual corresponde a la sumatoria de los elementos dividos en la cantidad de elementos. El promedio si bien es bastante util, es muy sensible a valores extremos, incluso una pequeña cantidad de datos extremos pueden corromper el promedio. Las cifras de un conjunto de datos que son extremadamente altas o extremadamente bajas en comparación con el resto de las cifras se llaman valores atípicos. Debido a la forma de hacer los cálculos, los valores atípicos altos tienden a subir o bajar la media Para esto se puede calcular La media Truncada lo cual se refiere a remover los valores extremos, por ejemplo podemos quitar del el 2% del top y del bottom de la data. import numpy as np np.mean(data) Mediana Para valores asimetricos la mejor medida del centro de los datos es la Mediana La mediana corresponde a el valor medio de una lista de valores ordenados, dejando la misma cantidad de valores a un lado que al otro, la mediana entonces corresponde al valor que separa la parte mas alta de un grafico de la parte mas baja. Lo mas importante para el calculo de la mediana es que los datos este ordenados de manera ascendente o descendente. Si el conjunto de datos contiene un número impar de cifras, elige la que esté exactamente en el centro. Ésa es la mediana. Si el conjunto de datos contiene un número par de cifras, coge las dos del centro y calcula la media para obtener la mediana. import numpy as np np.median(data) Moda La moda es el valor que mas se repite dentro del conjunto de datos. a diferencia de la media no se ve afectada por valores atipicos al igual que la mediana. import numpy as np import scipy.stats as stats stats.mode(data) Desviacion La desviacion es una medicion que indica que tan dispersos son los datos, o que tan alejados estan de la media, &#34;La desviación estándar puede ser difícil de interpretar como número aislado. Básicamente, una desviación estándar pequeña significa que la mayoría de los valores del conjunto de datos están próximos a la media de ese conjunto, y una desviación estándar grande significa que la mayoría de los valores del conjunto de datos están más alejados de la media&#34;. (Estadisticas para dummies) import numpy as np import scipy.stats as stats np.std(data) Representacion grafica La representacion grafica de las variables variara segun lo que se quiera observar: 1. Comparacion: el objetivo es comparar atributos, puede ser un grafico de barras o puntos. 2. Relaciones: Comprender la relacion entre dos o mas atributos. Para determinar si existe un patron entre dos variables numericas. 3. Composicion : Comprender como se compone una variable, diagrama de torta o e barras 4. Distribucion: Esta categoria permite observar como se distribuyen los datos. Suele utilizarse en la exploracion de los datos, el tipo de grafico dependera a que tipo de variable corresponda el atributo, ya sea cuantitativo o cualitativo. Los atributos categoricos pueden ser representados por un grafico de sectores o Torta, los cuales son para observar la composicion del atributo, lo ideal es que sean pocas categoricas para que sea mas claro. Tambien se debe considerar el tipo de variable al escoger el grafico. Relaciones Segun la ayuda de eleccion de graficos, las relaciones son mediante graficos de dispersion o de burbujas. entre las dos variables continuas del conjunto Ejemplo : Precio vs Puntos. Distribucion Los gráficos de distribución/histogramas se usan para conocer la frecuencia de los como valores de una variable y responden a preguntas del estilo: ¿Número de clientes qué tengo por grupo de edad? ¿Cuántos días tardan nuestros pagos? Si la representación es de una única variable y son pocos los datos que hay se utiliza gráficos de barras (Bar histogram). Por ejemplo: Número de habitantes por Comunidad Autónoma. Si la representación es de una única variable y hay muchos datos se utilizan gráfico lineales (Line histogram). Si se quiere representar dos variables hay varias opciones como utilizar gráfico de Scatter plot o de barras con distinto color o varios gráficos. Extraido de --&gt; analitica-de-datos-con-python-y-sofia2-14-graficos-de-distribucion. 1 Comparacion A traves del tiempo o entre categorias. En este tipo de graficos se utiliza principalmente el grafico de barras, es necesario que al menos uno de los ejes sea numerico Histogramas si la variable es numerica entonces es llamado histograma, la variable x esta dento de rangos, lo usual es que los rangos sean iguales, dentro de cada rango se despliega la barra con la cantidad de observaciones en ese rango. plt.figure(figsize = (12,8)) # Tamaño de la figura data[data[&#34;Precio&#34;]&lt;200][&#34;Precio&#34;].plot.hist() idem sns.distplot() Boxplot los graficos de tipo boxplot permiten Visualizar una variable numerica, utila valores Cuartiles,Extremos,valores raros o outiers Pivot Table Similar a las tablas temporales de sql, permite seleccionar ciertos atributos del conjunto de datos, agrupa en base a un indice mediante el parametro index, a su vez pueden mostrar estimadores estadisticos ya sea promedio o un conjunto de estos. pd.pivot_table(index=[&#34;Atributo&#34;,&#34;Atributo2&#34;,&#34;Atributo n&#34;]) pd.pivot_table(index,values=&#34;Atributo&#34;,aggfunc=[&#34;mean&#34;,np.median]) a su vez la tabla generada permite hacerle un query tab.query(&#34;Variedad ==[&#39;Agiorgitiko&#39;]&#34;) Catplot Catplot es un tipo de grafico de dispersion categorica.", 
            "tags": "misc", 
            "loc": "https://c3rssei.github.io/Blog/descubrir-tu-data-conceptos.html"
        }        
    ]
}