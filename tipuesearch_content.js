var tipuesearch = {"pages":[{"title":"Titanic Naives Bayes","text":"End to End Titanic Naive Bayes Homework º2 Naives bayes woman who code datascience In [60]: import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns Lectura del Dataset, desplegar top/bottom In [61]: data = pd . read_csv ( \"train.csv\" ) kaggle = pd . read_csv ( \"test.csv\" ) In [62]: data . head ( 2 ) Out[62]: PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C In [63]: data . tail ( 2 ) Out[63]: PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 889 890 1 1 Behr, Mr. Karl Howell male 26.0 0 0 111369 30.00 C148 C 890 891 0 3 Dooley, Mr. Patrick male 32.0 0 0 370376 7.75 NaN Q Etapas de un EDA Tipo de datos Espacio de la Solucion Espacio de las variables Rango de valores Variables Categoricas Variables Numericas % Missing Unique Values Outliers Distribucion Resumen del Dataset In [64]: data . info () <class 'pandas.core.frame.DataFrame'> RangeIndex: 891 entries, 0 to 890 Data columns (total 12 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 PassengerId 891 non-null int64 1 Survived 891 non-null int64 2 Pclass 891 non-null int64 3 Name 891 non-null object 4 Sex 891 non-null object 5 Age 714 non-null float64 6 SibSp 891 non-null int64 7 Parch 891 non-null int64 8 Ticket 891 non-null object 9 Fare 891 non-null float64 10 Cabin 204 non-null object 11 Embarked 889 non-null object dtypes: float64(2), int64(5), object(5) memory usage: 83.7+ KB In [65]: #Estadisticas datos numericos data . describe () #Se observan los primeros problemas, Pclass debiese ser categorico Out[65]: PassengerId Survived Pclass Age SibSp Parch Fare count 891.000000 891.000000 891.000000 714.000000 891.000000 891.000000 891.000000 mean 446.000000 0.383838 2.308642 29.699118 0.523008 0.381594 32.204208 std 257.353842 0.486592 0.836071 14.526497 1.102743 0.806057 49.693429 min 1.000000 0.000000 1.000000 0.420000 0.000000 0.000000 0.000000 25% 223.500000 0.000000 2.000000 20.125000 0.000000 0.000000 7.910400 50% 446.000000 0.000000 3.000000 28.000000 0.000000 0.000000 14.454200 75% 668.500000 1.000000 3.000000 38.000000 1.000000 0.000000 31.000000 max 891.000000 1.000000 3.000000 80.000000 8.000000 6.000000 512.329200 In [66]: data . Pclass = data . Pclass . astype ( \"object\" ) In [67]: #Estadisticas datos categoricos data . describe ( include = \"object\" ) Out[67]: Pclass Name Sex Ticket Cabin Embarked count 891 891 891 891 204 889 unique 3 891 2 681 147 3 top 3 Smith, Mr. Richard William male CA. 2343 B96 B98 S freq 491 1 577 7 4 644 Que columnas eliminar In [68]: data . drop ( columns = \"Cabin\" , inplace = True ) #Elimino Cabin por tener un 70% de nulos kaggle . drop ( columns = \"Cabin\" , inplace = True ) data . drop ( columns = \"PassengerId\" , inplace = True ) kaggle . drop ( columns = \"PassengerId\" , inplace = True ) data . drop ( columns = \"Ticket\" , inplace = True ) #Ticket por contar con demasiados valores unicos kaggle . drop ( columns = \"Ticket\" , inplace = True ) In [69]: data . head () Out[69]: Survived Pclass Name Sex Age SibSp Parch Fare Embarked 0 0 3 Braund, Mr. Owen Harris male 22.0 1 0 7.2500 S 1 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 71.2833 C 2 1 3 Heikkinen, Miss. Laina female 26.0 0 0 7.9250 S 3 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 53.1000 S 4 0 3 Allen, Mr. William Henry male 35.0 0 0 8.0500 S Tipo de datos de cada atributo In [70]: data . dtypes Out[70]: Survived int64 Pclass object Name object Sex object Age float64 SibSp int64 Parch int64 Fare float64 Embarked object dtype: object Numero de entradas para cada atributo In [71]: data [ \"Age\" ] . count () #Retorna el total de valores no nulos Out[71]: 714 In [72]: data [ \"Age\" ] . size #Cada registro inclusive los nulos Out[72]: 891 In [73]: columnas = data . columns for i in columnas : count = data [ i ] . count () print ( \" %s : %d \" % ( i , count )) Survived :891 Pclass :891 Name :891 Sex :891 Age :714 SibSp :891 Parch :891 Fare :891 Embarked :889 % de Nulos en los atributos In [74]: missing = data . isnull () . sum () * 100 / len ( data ) Resumen = pd . DataFrame ({ \"% nulos\" : missing , }) Resumen . sort_values ( \"% nulos\" , ascending = False ) Out[74]: % nulos Age 19.865320 Embarked 0.224467 Survived 0.000000 Pclass 0.000000 Name 0.000000 Sex 0.000000 SibSp 0.000000 Parch 0.000000 Fare 0.000000 Reemplazar valores nulos In [75]: sns . set_palette ( \"hls\" ) data [ \"Age\" ] . plot ( kind = \"hist\" ) #Asimetrica a la derecha -- Cola Out[75]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6f45510> Referencia : https://www.siyavula.com/read/maths/grade-11/statistics/11-statistics-05 In [76]: sns . boxplot ( \"Age\" , data = data ) #La mediana se encuentra mas cercana al primer cuartil --Asimetrico a la derecha Out[76]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6ed3e10> In [77]: data [ \"Age\" ] . fillna ( data . Age . median (), inplace = True ) kaggle [ \"Age\" ] . fillna ( kaggle . Age . median (), inplace = True ) In [78]: sns . boxplot ( \"Age\" , data = data ) Out[78]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6e5b7d0> Fix Embarked In [79]: data . Embarked . mode () Out[79]: 0 S dtype: object In [80]: data . Embarked . fillna ( data . Embarked . mode ()[ 0 ], inplace = True ) In [81]: data . Embarked . isnull () . sum () Out[81]: 0 Analisis Univariado Atributos en el dataset In [82]: data . columns Out[82]: Index(['Survived', 'Pclass', 'Name', 'Sex', 'Age', 'SibSp', 'Parch', 'Fare', 'Embarked'], dtype='object') Graficos Atributos Numericos In [83]: #Age Fare plt . figure ( figsize = ( 15 , 15 )) plt . subplot ( 2 , 2 , 1 ) plt . title ( \"Histograma Age\" ) sns . distplot ( data [ \"Age\" ], hist = True ) plt . subplot ( 2 , 2 , 2 ) plt . title ( \"Boxplot Age\" ) sns . boxplot ( \"Age\" , data = data ) plt . subplot ( 2 , 2 , 3 ) plt . title ( \"Histograma Fare\" ) sns . distplot ( data [ \"Fare\" ], hist = True ) plt . subplot ( 2 , 2 , 4 ) plt . title ( \"Boxplot Fare\" ) sns . boxplot ( \"Fare\" , data = data ) Out[83]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6c9ced0> In [84]: #Numericos Discretos. #sibsp Number of Siblings/Spouses Aboard #parch Number of Parents/Children Aboard plt . figure ( figsize = ( 10 , 10 )) plt . subplot ( 2 , 1 , 1 ) plt . title ( \"SibSp Resume\" ) sns . countplot ( \"SibSp\" , data = data ) plt . subplot ( 2 , 1 , 2 ) plt . title ( \"Parch Resume\" ) sns . countplot ( \"Parch\" , data = data ) Out[84]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6ba6d50> Encontrar el total de pasajeros hombres/mujeres In [85]: data . groupby ( \"Sex\" ) . agg ( Total = ( \"Sex\" , \"count\" )) Out[85]: Total Sex female 314 male 577 In [86]: data . Sex . value_counts () . plot . pie () Out[86]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6ae3850> Cantidad de pasajeros por clase In [87]: data . groupby ( \"Pclass\" ) . agg ( Total = ( \"Pclass\" , \"count\" )) Out[87]: Total Pclass 1 216 2 184 3 491 In [88]: data [ \"Pclass\" ] . value_counts () . plot . pie () Out[88]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6ab4a10> Pasajeros solitarios In [89]: data [( data . SibSp == 0 ) & ( data . Parch == 0 )][ \"Name\" ] . count () Out[89]: 537 Pasajeros por Embarque In [90]: data . groupby ( \"Embarked\" ) . agg ( Total = ( \"Fare\" , \"count\" )) Out[90]: Total Embarked C 168 Q 77 S 646 In [91]: data . Embarked . value_counts () . plot . pie () Out[91]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6a8a250> Pasajeros y Sobrevivencia In [92]: data . groupby ( \"Survived\" ) . agg ( Tota = ( \"Survived\" , \"count\" )) Out[92]: Tota Survived 0 549 1 342 In [93]: data . Survived . value_counts () . plot . pie () Out[93]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d69d8b50> Rango de Edades del conjunto In [94]: rangos = [ \"nino\" , \"adulto\" ] cut_bins = [ 0 , 15 , 100 ] ''' niño : 0 - 15 adulto : 16 - 100 ''' data [ \"grupo_etario\" ] = pd . cut ( data [ \"Age\" ], bins = cut_bins , labels = rangos ) kaggle [ \"grupo_etario\" ] = pd . cut ( kaggle [ \"Age\" ], bins = cut_bins , labels = rangos ) In [95]: tabla = data . groupby ( \"grupo_etario\" ) . agg ( Total = ( \"grupo_etario\" , \"count\" )) tabla Out[95]: Total grupo_etario nino 83 adulto 808 In [96]: tabla . reset_index () tabla . sort_values ( \"Total\" , ascending = True , inplace = True ) sns . barplot ( x = tabla . index , y = tabla . Total , order = tabla . index ) Out[96]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d69a9690> % grupo etario segun clases In [97]: #Split nino = data [ data . grupo_etario == \"nino\" ] adulto = data [ data . grupo_etario == \"adulto\" ] #groups aux2 = nino . groupby ( \"Pclass\" ) . agg ( Total = ( \"Pclass\" , \"count\" )) aux2 [ \"%Total\" ] = aux2 . Total * 100 / aux2 . Total . sum () aux3 = adulto . groupby ( \"Pclass\" ) . agg ( Total = ( \"Pclass\" , \"count\" )) aux3 [ \"%Total\" ] = aux3 . Total * 100 / aux3 . Total . sum () nino = pd . DataFrame ({ \"Grupo\" : \"nino\" , \"Pclass\" : list ( aux2 . index ), \" %F recuencia\" : list ( aux2 [ \"%Total\" ]) }) adulto = pd . DataFrame ({ \"Grupo\" : \"adulto\" , \"Pclass\" : list ( aux3 . index ), \" %F recuencia\" : list ( aux3 [ \"%Total\" ]) }) aux = pd . concat ([ nino , adulto ], ignore_index = True ) sns . barplot ( \"Pclass\" , \" %F recuencia\" , hue = \"Grupo\" , data = aux ) plt . show () Sobrevivencia In [98]: sns . stripplot ( x = \"Survived\" , y = \"Fare\" , data = data ) Out[98]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6992650> In [99]: data . pivot_table ( index = \"Survived\" , values = \"Name\" , columns = \"Pclass\" , aggfunc = \"count\" ) . plot ( kind = \"bar\" ) Out[99]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6913950> In [100]: primeraclase = data . query ( \"Pclass==1\" ) segundaclase = data . query ( \"Pclass==2\" ) terceraclase = data . query ( \"Pclass==3\" ) primera = primeraclase . groupby ( \"Survived\" ) . agg ( Total = ( \"Survived\" , \"count\" )) primera [ \"% Total\" ] = primera [ \"Total\" ] * 100 / primera . Total . sum () segunda = segundaclase . groupby ( \"Survived\" ) . agg ( Total = ( \"Survived\" , \"count\" )) segunda [ \"% Total\" ] = segunda [ \"Total\" ] * 100 / segunda . Total . sum () tercera = terceraclase . groupby ( \"Survived\" ) . agg ( Total = ( \"Survived\" , \"count\" )) tercera [ \"% Total\" ] = tercera [ \"Total\" ] * 100 / tercera . Total . sum () primeraclase = pd . DataFrame ({ \"clase\" : 1 , \"sobreviviente\" : list ( primera . index ), \"%Total\" : list ( primera [ \"% Total\" ])}) segundaclase = pd . DataFrame ({ \"clase\" : 2 , \"sobreviviente\" : list ( segunda . index ), \"%Total\" : list ( segunda [ \"% Total\" ])}) terceraclase = pd . DataFrame ({ \"clase\" : 3 , \"sobreviviente\" : list ( tercera . index ), \"%Total\" : list ( tercera [ \"% Total\" ])}) clases = pd . concat ([ primeraclase , segundaclase , terceraclase ], ignore_index = True ) fig , ax = plt . subplots () ax = sns . barplot ( \"sobreviviente\" , \"%Total\" , hue = \"clase\" , data = clases ) In [101]: Sexo = data . groupby ( \"Sex\" )[ \"Survived\" ] . value_counts ( normalize = True ) . mul ( 100 ) . rename ( \"Porcentaje\" ) . reset_index () sns . barplot ( x = \"Survived\" , y = \"Porcentaje\" , hue = \"Sex\" , data = Sexo ) Out[101]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d678a510> In [102]: # embarked - Port of Embarkation (C = Cherbourg; Q = Queenstown; S = Southampton) sns . countplot ( \"Embarked\" , hue = \"Survived\" , data = data ) Out[102]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6699b90> In [103]: sns . stripplot ( x = \"Survived\" , y = \"Fare\" , data = data ) Out[103]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6693410> In [104]: sns . countplot ( \"grupo_etario\" , hue = \"Survived\" , data = data ) Out[104]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d65ed1d0> In [105]: data . pivot_table ( index = \"Survived\" , columns = \"grupo_etario\" , values = \"Name\" , aggfunc = \"count\" ) Out[105]: grupo_etario nino adulto Survived 0 34 515 1 49 293 En general podemos apreciar que: la primera clase tuvo un mayor % de sobrevivencia. Las mujeres en especial fueron las de mas alta sobrevivencia 80%, los hombres por el contrario son menos afortunados alcanzando solo un 20% de sobrevivencia. El embarque S fue el que mayor cantidad de sobreviventes tuvo. El grupo etario niños fue el que mayor porcentaje de sobrevivencia tuvo vs los adultos In [106]: data . pivot_table ( index = \"Survived\" , columns = \"Pclass\" , values = \"Fare\" , aggfunc = ( \"mean\" , \"median\" )) Out[106]: mean median Pclass 1 2 3 1 2 3 Survived 0 64.684008 19.412328 13.669364 44.7500 13.0 8.0500 1 95.608029 22.055700 13.694887 77.9583 21.0 8.5167 In [107]: #Tendencias globales sns . barplot ( x = \"grupo_etario\" , y = \"Fare\" , hue = \"Survived\" , data = data ) Out[107]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d65662d0> In [108]: sns . barplot ( x = \"Pclass\" , y = \"Fare\" , hue = \"Survived\" , data = data ) Out[108]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d654e510> In [109]: sns . stripplot ( x = \"Pclass\" , y = \"Fare\" , data = data , hue = \"Survived\" ) Out[109]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d646b390> Survived vs Sexo vs Clase Cambie la forma de realizar el grafico, ya que aprendi a hacerlo de diferentes formas en la marcha. https://www.shanelynn.ie/summarising-aggregation-and-grouping-data-in-python-pandas/ In [110]: data . pivot_table ( index = ( \"Survived\" , \"Sex\" ), columns = \"Pclass\" , values = \"Name\" , aggfunc = \"count\" ) . plot ( kind = \"bar\" ) data . pivot_table ( index = ( \"Survived\" , \"Sex\" ), columns = \"Pclass\" , values = \"Name\" , aggfunc = \"count\" ) . unstack ( \"Sex\" ) . plot ( kind = \"bar\" ) Out[110]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6491090> In [111]: data . groupby ([ \"Sex\" , \"Pclass\" ])[ \"Survived\" ] . value_counts ( normalize = True ) . mul ( 100 ) . rename ( \"Porcentaje\" ) . unstack ( \"Pclass\" ) . plot ( kind = \"bar\" ) Out[111]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d63db090> In [112]: data . pivot_table ( index = ( \"Survived\" , \"Sex\" ), values = \"Name\" , columns = \"Pclass\" , aggfunc = \"count\" ) Out[112]: Pclass 1 2 3 Survived Sex 0 female 3 6 72 male 77 91 300 1 female 91 70 72 male 45 17 47 In [113]: aux = data . pivot_table ( index = ( \"Survived\" , \"Sex\" ), columns = \"Pclass\" , values = \"Name\" , aggfunc = \"count\" ) aux [ \"%1\" ] = aux [ 1 ] * 100 / aux [ 1 ] . sum () aux [ \"%2\" ] = aux [ 2 ] * 100 / aux [ 2 ] . sum () aux [ \"%3\" ] = aux [ 3 ] * 100 / aux [ 3 ] . sum () aux . drop ( columns = [ 1 , 2 , 3 ], inplace = True ) aux . reset_index () aux . plot ( kind = \"bar\" , stacked = True ) Out[113]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d63ea210> Atributos Nuevos In [114]: data [ \"Passengers\" ] = data . Parch + data . SibSp + 1 kaggle [ \"Passengers\" ] = kaggle . Parch + kaggle . SibSp + 1 data [ \"Is_Alone\" ] = list (( map ( lambda x : x == 1 , data [ \"Passengers\" ]))) kaggle [ \"Is_Alone\" ] = list (( map ( lambda x : x == 1 , kaggle [ \"Passengers\" ]))) Observando los nuevos atributos In [115]: data . Is_Alone . value_counts () . plot . pie () Out[115]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d664ba90> In [116]: data . Passengers . value_counts () Out[116]: 1 537 2 161 3 102 4 29 6 22 5 15 7 12 11 7 8 6 Name: Passengers, dtype: int64 Relacion con Sobrevivencia In [117]: data . groupby ( \"Survived\" )[ \"Is_Alone\" ] . value_counts () #Al parecer existe una relacion inversa con sobrevivencia Out[117]: Survived Is_Alone 0 True 374 False 175 1 False 179 True 163 Name: Is_Alone, dtype: int64 In [118]: data . groupby ( \"Pclass\" )[ \"Is_Alone\" ] . value_counts ( normalize = True ) . mul ( 100 ) . unstack ( \"Is_Alone\" ) . plot ( kind = \"bar\" ) Out[118]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d62c8390> In [119]: data . query ( \"Survived==1\" ) . groupby ( \"Is_Alone\" )[ \"Pclass\" ] . value_counts ( normalize = True ) . mul ( 100 ) . unstack ( \"Pclass\" ) . plot ( kind = \"bar\" ) Out[119]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d6236f50> In [120]: data . groupby ( \"Passengers\" )[ \"Survived\" ] . value_counts ( normalize = True ) . mul ( 100 ) . unstack ( \"Survived\" ) Out[120]: Survived 0 1 Passengers 1 69.646182 30.353818 2 44.720497 55.279503 3 42.156863 57.843137 4 27.586207 72.413793 5 80.000000 20.000000 6 86.363636 13.636364 7 66.666667 33.333333 8 100.000000 NaN 11 100.000000 NaN In [121]: sns . countplot ( \"Passengers\" , hue = \"Survived\" , data = data ) Out[121]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d61bd590> Titulo-Extraccion de Nombre In [122]: def getname ( name ): if \".\" in name : return ( name . split ( \",\" )[ 1 ] . split ( \".\" )[ 0 ]) else : return ( \"unknow\" ) In [123]: Titulo = pd . DataFrame ( map ( getname , data [ \"Name\" ] . tolist ()), columns = [ \"Titulo\" ]) data [ \"Titulo\" ] = Titulo Titulo = pd . DataFrame ( map ( getname , kaggle [ \"Name\" ] . tolist ()), columns = [ \"Titulo\" ]) kaggle [ \"Titulo\" ] = Titulo data . info () <class 'pandas.core.frame.DataFrame'> RangeIndex: 891 entries, 0 to 890 Data columns (total 13 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Survived 891 non-null int64 1 Pclass 891 non-null object 2 Name 891 non-null object 3 Sex 891 non-null object 4 Age 891 non-null float64 5 SibSp 891 non-null int64 6 Parch 891 non-null int64 7 Fare 891 non-null float64 8 Embarked 891 non-null object 9 grupo_etario 891 non-null category 10 Passengers 891 non-null int64 11 Is_Alone 891 non-null bool 12 Titulo 891 non-null object dtypes: bool(1), category(1), float64(2), int64(4), object(5) memory usage: 78.5+ KB In [124]: data [ \"Titulo\" ] . value_counts () Out[124]: Mr 517 Miss 182 Mrs 125 Master 40 Dr 7 Rev 6 Col 2 Mlle 2 Major 2 Capt 1 Ms 1 Lady 1 Mme 1 Jonkheer 1 Don 1 Sir 1 the Countess 1 Name: Titulo, dtype: int64 In [125]: Reemplazos = { \" Mlle\" : \"Miss\" , \" Ms\" : \"Miss\" , \" Mme\" : \"Mr\" , \" Mlle\" : \"Miss\" , \" Lady\" : \"Royalty\" , \" the Countess\" : \"Royalty\" , \" Don\" : \"Royalty\" , \" Sir\" : \"Royalty\" , \" Jonkheer\" : \"Royalty\" , \" Dona\" : \"Royalty\" , \" Capt\" : \"Special\" , \" Col\" : \"Special\" , \" Dr\" : \"Special\" , \" Major\" : \"Special\" , \" Rev\" : \"Special\" , \" Mr\" : \"Mr\" , \" Miss\" : \"Miss\" , \" Mrs\" : \"Mrs\" , \" Master\" : \"Master\" } data . replace ({ \"Titulo\" : Reemplazos }, inplace = True ) kaggle . replace ({ \"Titulo\" : Reemplazos }, inplace = True ) data [ \"Titulo\" ] . value_counts () Out[125]: Mr 518 Miss 185 Mrs 125 Master 40 Special 18 Royalty 5 Name: Titulo, dtype: int64 In [126]: sns . countplot ( \"Titulo\" , hue = \"Survived\" , data = data ) Out[126]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d60e36d0> In [127]: data . groupby ( \"Titulo\" )[ \"Survived\" ] . value_counts ( normalize = True ) . mul ( 100 ) . unstack ( \"Survived\" ) . plot ( kind = \"bar\" ) Out[127]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d607ba10> Eliminacion de atributos In [128]: data . drop ( columns = [ \"Name\" , \"SibSp\" , \"Parch\" , \"Age\" ], inplace = True ) kaggle . drop ( columns = [ \"Name\" , \"SibSp\" , \"Parch\" , \"Age\" ], inplace = True ) naives bayes asume que todos los atributos son independientes de otros. A su vez los atributos deben ser categoricos por naturaleza terminologia step 1: Calcular Probabilidad del target In [129]: target = data . groupby ( \"Survived\" ) . agg ( Frecuencia = ( \"Survived\" , \"count\" )) target [ \"Prob\" ] = target [ \"Frecuencia\" ] / target [ \"Frecuencia\" ] . sum () target Out[129]: Frecuencia Prob Survived 0 549 0.616162 1 342 0.383838 Step 2: Calcular las probabilidades de los predictores dado el target In [130]: Clase = pd . crosstab ( data . Pclass , data . Survived ) Clase [ \"Prob_0\" ] = Clase [ 0 ] / Clase [ 0 ] . sum () Clase [ \"Prob_1\" ] = Clase [ 1 ] / Clase [ 1 ] . sum () In [131]: Clase . columns Out[131]: Index([0, 1, 'Prob_0', 'Prob_1'], dtype='object', name='Survived') In [132]: Sex = pd . crosstab ( data . Sex , data . Survived ) Sex [ \"Prob_0\" ] = Sex [ 0 ] / Sex [ 0 ] . sum () Sex [ \"Prob_1\" ] = Sex [ 1 ] / Sex [ 1 ] . sum () Sex Out[132]: Survived 0 1 Prob_0 Prob_1 Sex female 81 233 0.147541 0.681287 male 468 109 0.852459 0.318713 In [133]: Embarked = pd . crosstab ( data . Embarked , data . Survived ) Embarked [ \"Prob_0\" ] = Embarked [ 0 ] / Embarked [ 0 ] . sum () Embarked [ \"Prob_1\" ] = Embarked [ 1 ] / Embarked [ 1 ] . sum () Embarked Out[133]: Survived 0 1 Prob_0 Prob_1 Embarked C 75 93 0.136612 0.271930 Q 47 30 0.085610 0.087719 S 427 219 0.777778 0.640351 In [134]: grupo = pd . crosstab ( data . grupo_etario , data . Survived ) grupo [ \"Prob_0\" ] = grupo [ 0 ] / grupo [ 0 ] . sum () grupo [ \"Prob_1\" ] = grupo [ 1 ] / grupo [ 1 ] . sum () grupo Out[134]: Survived 0 1 Prob_0 Prob_1 grupo_etario nino 34 49 0.061931 0.143275 adulto 515 293 0.938069 0.856725 In [135]: alone = pd . crosstab ( data . Is_Alone , data . Survived ) alone [ \"Prob_0\" ] = alone [ 0 ] / alone [ 0 ] . sum () alone [ \"Prob_1\" ] = alone [ 1 ] / alone [ 1 ] . sum () alone Out[135]: Survived 0 1 Prob_0 Prob_1 Is_Alone False 175 179 0.318761 0.523392 True 374 163 0.681239 0.476608 In [136]: titulo = pd . crosstab ( data . Titulo , data . Survived ) titulo [ \"Prob_0\" ] = titulo [ 0 ] / titulo [ 0 ] . sum () titulo [ \"Prob_1\" ] = titulo [ 1 ] / titulo [ 1 ] . sum () titulo Out[136]: Survived 0 1 Prob_0 Prob_1 Titulo Master 17 23 0.030965 0.067251 Miss 55 130 0.100182 0.380117 Mr 436 82 0.794171 0.239766 Mrs 26 99 0.047359 0.289474 Royalty 2 3 0.003643 0.008772 Special 13 5 0.023679 0.014620 ¿Cual es la probabilidad de sobrevivir siendo de primera clase, adulto, hombre, embarque c y titulo royalty? $P(yes|1ª,adult,men,C,Royalty) = p(1ª|yes) * p(adult|yes)* p(men|yes)* p(embarked =C|yes)* p(Royalty|yes) * p(yes) * P(Mother|yes) / p(1º)* p(adult)* p(men) * p(C) * p(Royalty) * p(Mother)$ In [137]: a = Clase [ \"Prob_1\" ][ 1 ] * Sex [ \"Prob_1\" ][ \"female\" ] * titulo [ \"Prob_1\" ][ \"Mrs\" ] * Embarked [ \"Prob_1\" ][ \"S\" ] * grupo [ \"Prob_1\" ][ \"adulto\" ] * target [ \"Prob\" ][ 1 ] In [138]: b = ( Clase [ 1 ][ 1 ] + Clase [ 0 ][ 1 ] ) / len ( data ) \\ + ( Sex [ 0 ][ \"female\" ] + Sex [ 1 ][ \"female\" ]) / len ( data ) + \\ ( titulo [ 0 ][ \"Mrs\" ] + titulo [ 1 ][ \"Mrs\" ]) / len ( data ) \\ + ( Embarked [ 0 ][ \"S\" ] + Embarked [ 1 ][ \"S\" ]) / len ( data ) \\ + ( grupo [ 0 ][ \"adulto\" ] + grupo [ 1 ][ \"adulto\" ]) / len ( data ) In [139]: a / b Out[139]: 0.006976871998102452 Scikit Learn Trasformando atributos In [140]: #Custom encoding clase = { \"Pclass\" :{ \"1\" : 1 , \"2\" : 2 , \"3\" : 3 }} data . replace ( clase , inplace = True ) In [142]: kaggle . dtypes Out[142]: Pclass int64 Sex object Fare float64 Embarked object grupo_etario category Passengers int64 Is_Alone bool Titulo object dtype: object In [143]: kaggle [ \"Fare\" ] . fillna ( kaggle . Fare . median (), inplace = True ) ''' test[\"Fare\"]=test[\"Fare\"].astype(\"int64\") test[\"grupo_etario\"]=test[\"grupo_etario\"].astype(\"category\") test[\"Is_Alone\"]=test[\"Is_Alone\"].astype(\"category\") test[\"Titulo\"]=test[\"Titulo\"].astype(\"category\") ''' Out[143]: '\\ntest[\"Fare\"]=test[\"Fare\"].astype(\"int64\")\\ntest[\"grupo_etario\"]=test[\"grupo_etario\"].astype(\"category\")\\ntest[\"Is_Alone\"]=test[\"Is_Alone\"].astype(\"category\")\\ntest[\"Titulo\"]=test[\"Titulo\"].astype(\"category\")\\n' In [144]: #Todos los atributos a numericos. from sklearn.preprocessing import LabelEncoder encode = LabelEncoder () def tipe ( lista , aux ): encodeaux = [] for i in lista : if (( aux [ i ] . dtypes == \"object\" ) | ( aux [ i ] . dtypes . name == \"category\" ) | ( aux [ i ] . dtypes == \"bool\" )): encodeaux . append ( i ) return encodeaux aux = tipe ( data . columns , data ) for i in aux : data [ i ] = encode . fit_transform ( data [ i ]) aux1 = tipe ( kaggle . columns , kaggle ) for i in aux1 : kaggle [ i ] = encode . fit_transform ( kaggle [ i ]) In [145]: data . dtypes Out[145]: Survived int64 Pclass int64 Sex int64 Fare float64 Embarked int64 grupo_etario int64 Passengers int64 Is_Alone int64 Titulo int64 dtype: object In [146]: kaggle . dtypes Out[146]: Pclass int64 Sex int64 Fare float64 Embarked int64 grupo_etario int64 Passengers int64 Is_Alone int64 Titulo int64 dtype: object Correlacion In [147]: correlation = data . corr () correlation [ \"Survived\" ] . sort_values () Out[147]: Sex -0.543351 Pclass -0.338481 Is_Alone -0.203367 Embarked -0.167675 Titulo -0.072741 Passengers 0.016639 grupo_etario 0.136107 Fare 0.257307 Survived 1.000000 Name: Survived, dtype: float64 In [148]: correlation Out[148]: Survived Pclass Sex Fare Embarked grupo_etario Passengers Is_Alone Titulo Survived 1.000000 -0.338481 -0.543351 0.257307 -0.167675 0.136107 0.016639 -0.203367 -0.072741 Pclass -0.338481 1.000000 0.131900 -0.549500 0.162098 0.121920 0.065997 0.135207 -0.190218 Sex -0.543351 0.131900 1.000000 -0.182333 0.108262 -0.111141 -0.200988 0.303646 0.072362 Fare 0.257307 -0.549500 -0.182333 1.000000 -0.224719 0.003753 0.217138 -0.271832 -0.011561 Embarked -0.167675 0.162098 0.108262 -0.224719 1.000000 -0.012338 0.066516 0.063532 0.007955 grupo_etario 0.136107 0.121920 -0.111141 0.003753 -0.012338 1.000000 0.416472 -0.347400 -0.471455 Passengers 0.016639 0.065997 -0.200988 0.217138 0.066516 0.416472 1.000000 -0.690922 -0.193182 Is_Alone -0.203367 0.135207 0.303646 -0.271832 0.063532 -0.347400 -0.690922 1.000000 0.021031 Titulo -0.072741 -0.190218 0.072362 -0.011561 0.007955 -0.471455 -0.193182 0.021031 1.000000 In [149]: plt . figure ( figsize = ( 8 , 6 )) sns . heatmap ( data . corr ()) Out[149]: <matplotlib.axes._subplots.AxesSubplot at 0x7f68d5dd8450> Bernoulli Bernoulli NB classifier works on discrete data with Binary or boolean features Referencia --Woman who code notebook Variables continuas a categoricas In [150]: ''' Fare Passengers ''' backup = data . copy () backup [ \"Fare_q\" ], bins = pd . qcut ( backup [ \"Fare\" ], q = 4 , labels = False , retbins = True ) backup . drop ( \"Fare\" , axis = 1 , inplace = True ) kaggle [ \"Fare_q\" ], bins = pd . qcut ( kaggle [ \"Fare\" ], q = 4 , labels = False , retbins = True ) kaggle . drop ( \"Fare\" , axis = 1 , inplace = True ) In [151]: backup [[ \"Fare_q\" ]][: 5 ] Out[151]: Fare_q 0 0 1 3 2 1 3 3 4 1 In [152]: backup . Passengers . value_counts () Out[152]: 1 537 2 161 3 102 4 29 6 22 5 15 7 12 11 7 8 6 Name: Passengers, dtype: int64 In [206]: #Model 1 --Dummies passengers from sklearn.model_selection import train_test_split train , test = train_test_split ( backup , test_size = 0.4 , random_state = 101 , shuffle = True ) In [207]: y_train = train [ \"Survived\" ] X_train = train . drop ([ \"Survived\" ], axis = 1 ) y_test = test [ \"Survived\" ] X_test = test . drop ([ \"Survived\" ], axis = 1 ) In [208]: X_train_enc = pd . get_dummies ( data = X_train , columns = X_train . columns ) X_test_enc = pd . get_dummies ( data = X_test , columns = X_test . columns ) X_train_enc , X_test_enc = X_train_enc . align ( X_test_enc , join = 'left' , axis = 1 ) X_test_enc = X_test_enc . fillna ( 0 ) In [209]: X_train_enc [: 5 ] Out[209]: Pclass_1 Pclass_2 Pclass_3 Sex_0 Sex_1 Embarked_0 Embarked_1 Embarked_2 grupo_etario_0 grupo_etario_1 ... Titulo_0 Titulo_1 Titulo_2 Titulo_3 Titulo_4 Titulo_5 Fare_q_0 Fare_q_1 Fare_q_2 Fare_q_3 124 1 0 0 0 1 0 0 1 1 0 ... 0 0 1 0 0 0 0 0 0 1 745 1 0 0 0 1 0 0 1 1 0 ... 0 0 0 0 0 1 0 0 0 1 653 0 0 1 1 0 0 1 0 1 0 ... 0 1 0 0 0 0 1 0 0 0 272 0 1 0 1 0 0 0 1 1 0 ... 0 0 0 1 0 0 0 0 1 0 868 0 0 1 0 1 0 0 1 1 0 ... 0 0 1 0 0 0 0 1 0 0 5 rows × 31 columns In [210]: from sklearn.naive_bayes import BernoulliNB from sklearn.metrics import recall_score , precision_score , accuracy_score , f1_score from sklearn.metrics import confusion_matrix , auc , roc_auc_score , roc_curve clf_bern1 = BernoulliNB () clf_bern1 . fit ( X_train_enc , y_train ) Out[210]: BernoulliNB() In [211]: y_pred_bern1 = clf_bern1 . predict ( X_test_enc ) y_prob_bern1 = clf_bern1 . predict_proba ( X_test_enc ) In [212]: #y_test.drop(\"PassengerId\",axis=1,inplace=True) In [213]: print ( 'test-set confusion matrix: \\n ' , confusion_matrix ( y_test , y_pred_bern1 )) print ( \"recall score: \" , recall_score ( y_test , y_pred_bern1 )) print ( \"precision score: \" , precision_score ( y_test , y_pred_bern1 )) print ( \"f1 score: \" , f1_score ( y_test , y_pred_bern1 )) print ( \"accuracy score: \" , accuracy_score ( y_test , y_pred_bern1 )) test-set confusion matrix: [[174 33] [ 42 108]] recall score: 0.72 precision score: 0.7659574468085106 f1 score: 0.7422680412371133 accuracy score: 0.7899159663865546 Modelo 2 Remover los atributos que esten altamente relacionados con el target. In [ ]:","tags":"posts","url":"https://c3rssei.github.io/Blog/titanic-naives-bayes.html","loc":"https://c3rssei.github.io/Blog/titanic-naives-bayes.html"},{"title":"Visualizacion de datos","text":"Visualizacion de datos Las visualizaciones fueron realizadas con el dataset del titanic, principalmente utilizo seaborn aun asi por temas de aprendizaje en algunos graficos ocupo matplotlib. La representacion grafica de las variables variara segun lo que se quiera observar: Comparacion: el objetivo es comparar atributos, puede ser un grafico de barras o puntos. Relaciones: Comprender la relacion entre dos o mas atributos. Para determinar si existe un patron entre dos variables numericas. Composicion : Comprender como se compone una variable, diagrama de torta o e barras Distribucion: Esta categoria permite observar como se distribuyen los datos. Suele utilizarse en la exploracion de los datos, el tipo de grafico dependera a que tipo de variable corresponda el atributo, ya sea cuantitativo o cualitativo. Los atributos categoricos pueden ser representados por un grafico de sectores o Torta, los cuales son para observar la composicion del atributo, lo ideal es que sean pocas categoricas para que sea mas claro. Tambien se debe considerar el tipo de variable al escoger el grafico In [1]: import numpy as np import pandas as pd import seaborn as sns import matplotlib.pyplot as plt In [2]: data = pd . read_csv ( \"train.csv\" ) When creating visualizations, the first step is to be clear on the question to be answered. In other words, how is visualization going to help? Mastering python data visualization, Kirthi Raman pie chart is best used to compare the parts of a whole. However, bar graphs can compare things between different groups to show patterns Bar graphs are especially effective when you have numerical data that splits nicely into different categories, so you can quickly see trends within your data. Bar graphs are useful when comparing data across categories. Mastering python data visualization, Kirthi Raman In [3]: data . head () Out[3]: PassengerId Survived Pclass Name Sex Age SibSp Parch Ticket Fare Cabin Embarked 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S In [4]: cabecera = [ \"ID\" , \"Sobreviviente\" , \"Clase\" , \"Nombre\" , \"Sexo\" , \"edad\" , \"Hermanos\" , \"Hijos\" , \"Ticket\" , \"Tarifa\" , \"Cabina\" , \"Embarque\" ] data . columns = cabecera data . head ( 5 ) Out[4]: ID Sobreviviente Clase Nombre Sexo edad Hermanos Hijos Ticket Tarifa Cabina Embarque 0 1 0 3 Braund, Mr. Owen Harris male 22.0 1 0 A/5 21171 7.2500 NaN S 1 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Th... female 38.0 1 0 PC 17599 71.2833 C85 C 2 3 1 3 Heikkinen, Miss. Laina female 26.0 0 0 STON/O2. 3101282 7.9250 NaN S 3 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35.0 1 0 113803 53.1000 C123 S 4 5 0 3 Allen, Mr. William Henry male 35.0 0 0 373450 8.0500 NaN S In [5]: data . drop ( labels = [ \"Cabina\" , \"Ticket\" ], axis = 1 , inplace = True ) Scatter works well when having a lot of data values In [6]: #pregunta cuantos Sobrevivientes hubieron por clase? aux = data . groupby ( \"Clase\" ) . agg ( Sobrevivientes = ( \"Sobreviviente\" , \"sum\" )) fig , ax = plt . subplots ( figsize = ( 10 , 10 )) plt . bar ( aux . index , aux [ \"Sobrevivientes\" ], align = 'center' , color = sns . color_palette ( \"coolwarm\" )) for i , val in enumerate ( aux . values ): plt . text ( i + 1 , val , float ( val ), verticalalignment = 'bottom' ) #plt.text(x_pos, y_pos, \"text on plot\") plt . title ( \"Pasajeros Sobrevivientes segun Clases\" , fontdict = { \"fontname\" : \"Fantasy\" , \"fontsize\" : 17 }) plt . ylabel ( \"Cantidad de Sobrevivientes\" , fontdict = { \"fontsize\" : 12 }) plt . xticks ([ 1 , 2 , 3 ]) ax . set_xticklabels ([ \"Clase 1\" , \"Clase 2\" , \"Clase 3\" ]) plt . show () findfont: Font family ['Fantasy'] not found. Falling back to DejaVu Sans. In [7]: data = pd . get_dummies ( data , columns = [ \"Sexo\" ]) data . drop ( labels = [ \"Sexo_male\" ], axis = 1 , inplace = True ) fix , ax = plt . subplots () ax = sns . countplot ( \"Sexo_female\" , hue = \"Sobreviviente\" , data = data ,) for p in ax . patches : ax . annotate ( f ' { p . get_height () } ' , ( p . get_x () + 0.2 , p . get_height ()), ha = 'center' , va = 'top' , size = 12 ) plt . show () Titulos Para ingresar titulos en los graficos se utiliza plt.title(\"Titulo\") plt.title(\"Grafico\",fontdict={\"fontname\":\"Comic Sans MS\", \"fontsize\":17}) Plot Types Scatter plot scatter plot muestra la relacion entre las variables numericas. por ejemplo: la relacion entre tener cancer y las diferentes edades de hombres vs mujeres Se puede agregar una linea que muestre la correlacion entre los datos. In [8]: #Edad , Tarifa y sobreviviente g = sns . FacetGrid ( data , col = 'Sobreviviente' , palette = \"set1\" , height = 10 ) g . map ( sns . scatterplot , \"edad\" , \"Tarifa\" , s = 140 , linewidth =. 7 , edgecolor = \"#ffad40\" , color = \"#ff8000\" ) g . add_legend () plt . show () Sizes Los scatter plot se pueden personalizar con el parametro sizes que a medida que un atributo aumenta tambien aumenta el tamaño del punto observado. In [9]: fig , ax = plt . subplots ( figsize = ( 10 , 10 )) sns . scatterplot ( \"edad\" , \"Tarifa\" , hue = \"Sobreviviente\" , data = data , linewidth =. 7 , size = \"Tarifa\" ) plt . title ( \"Distribuciòn de sobreviviente segun tarifa y edad\" , fontdict = { \"fontsize\" : 14 }) plt . show () Histograma Un histograma representa la distribucion de atributos numericos. usualmente los rangos de valores son hechos por bins de igual tamaño, el alto de la barra corresponde a la frecuencia de los valores en ese rango. Lo principal de un histograma es que se puede observar que tendencia tienen los datos, si es simetrica o asimitrica a la derecha o a la izquierda. In [10]: plt . hist ( data [ \"edad\" ]) /home/mariajose/anaconda3/lib/python3.7/site-packages/numpy/lib/histograms.py:839: RuntimeWarning: invalid value encountered in greater_equal keep = (tmp_a >= first_edge) /home/mariajose/anaconda3/lib/python3.7/site-packages/numpy/lib/histograms.py:840: RuntimeWarning: invalid value encountered in less_equal keep &= (tmp_a <= last_edge) Out[10]: (array([ 54., 46., 177., 169., 118., 70., 45., 24., 9., 2.]), array([ 0.42 , 8.378, 16.336, 24.294, 32.252, 40.21 , 48.168, 56.126, 64.084, 72.042, 80. ]), <a list of 10 Patch objects>) In [11]: fig , ax = plt . subplots ( figsize = ( 10 , 10 )) sns . distplot ( data [ \"edad\" ]) plt . title ( \"Histograma Edad\" , fontdict = { \"fontsize\" : 20 }) Out[11]: Text(0.5, 1.0, 'Histograma Edad') In [12]: data [ \"edad\" ] . fillna ( np . median ( data [ \"edad\" ]), inplace = True ) In [13]: plt . hist ( data [ \"edad\" ]) plt . show () Grafica Nube de puntos Este tipo de grafico dibuja un punto por cada observacion. In [14]: plt . figure ( figsize = ( 10 , 10 )) plt . plot ( data [ \"edad\" ], 'o' , markersize = 5 ) plt . show () Box plot Los diagramas de caja permiten apreciar como se distribuyen los valores de una variable, si es que se encuentran mas o menos concentrados o dispersos de acuerdo a los cuartiles y si existen outliers Box plots are most useful in showing the distribution of a set of data. Some notable examples are as follows: Identifying outliers in the data Determining how the data is skewed towards either end In addition to this, consider the following: Hide the points within the box: focus on the outliers Compare across distributions: Box plots Mastering python data visualization, Kirthi Raman Los cuartiles corresponden a los valores que tiene una variable y que cumplen con la funcion de dividir los datos ordenados en cuatro partes con igual valor porcentual, como recordatorio personal lo primero que se debe hacer para calcular los cuartiles es ordenar de menor a mayor los datos, mediante la formula k*N donde k_ 1,2,3 --- N : Numero de elementos del conjunto 4 In [15]: fig , ax = plt . subplots ( figsize = ( 8 , 8 )) sns . color_palette ( \"pastel\" ) sns . boxplot ( y = data [ \"Tarifa\" ]) plt . ylim ( - 10 , 70 ) plt . show () #El boxplot generado nos indica que el valor minimo es 0 , la mediana es aprox 15 #extremo superior aprox es 65 luego de este valor son considerados como outliers Boxplot bivariado. como parametro puede recibir hue y order. donde hue nos agrega otra capa de distribucion y el order nos permite determinar el orden de aparicion de los boxplot In [16]: fig , ax = plt . subplots ( figsize = ( 8 , 8 )) sns . set_context ( 'notebook' ) sns . color_palette ( \"pastel\" ) sns . boxplot ( x = data [ \"Clase\" ], y = data [ \"Tarifa\" ], order = [ 3 , 2 , 1 ]) plt . show () Pie Chart o Grafico de Torta Un pie chart tiene como principal funcion mostrar las proporciones de las categorias como parte de un todo Del mismo libro Mastering python data visualization, Kirthi Raman Limit pie wedges to eight : If there are more than eight proportions to represent, consider a bar graph. Due to limited real - estate, it is difficult to meaningfully represent and interpret the pieces. In [18]: fig , ax = plt . subplots () data [ \"Sexo_female\" ] . value_counts () . plot . pie ( autopct = ' %1.1f%% ' , shadow = False ) plt . show () Pair grid y Pair plot --Seaborn pairgrid genera visualizacion de pares, primero indico que atributos se utilizaran y luego que tipo de grafico quiero ver. g = sns . PairGrid ( data , vars = [ \"edad\" , \"Tarifa\" ]) g = g . map ( plt . scatter ) Se generan dos conjuntos de graficos en donde se alternan los atributos en los ejes. Personalizar las diagonales g = g . map_diag ( plt . hist ) g = g . mapoffdiag ( plt . scatter ) Pairplot genera todos los graficos de correlacion para los diferentes atributos, se puede generar solo en base a determinados atributos In [19]: sns . pairplot ( data , kind = \"scatter\" , hue = \"Sobreviviente\" , palette = 'RdBu' ) plt . show () /home/mariajose/anaconda3/lib/python3.7/site-packages/seaborn/distributions.py:369: UserWarning: Default bandwidth for data is 0; skipping density estimation. warnings.warn(msg, UserWarning) In [20]: g = sns . PairGrid ( data , vars = [ \"edad\" , \"Tarifa\" ], hue = \"Sobreviviente\" ) g = g . map_diag ( plt . hist ) g = g . map_offdiag ( plt . scatter ) plt . legend () plt . show () Otros Point plot Similar a un barplot salvo que solo representa la medida de tendencia central. In [21]: sns . pointplot ( y = data [ \"edad\" ], x = data [ \"Clase\" ], hue = data [ \"Sobreviviente\" ]) Out[21]: <matplotlib.axes._subplots.AxesSubplot at 0x7fdf9ed29e90> Stripplot Strip plot es un scatter plot pero de variables categoricas , tambien puede ser univariado pero debe ser un atributo numerico.</br> Parametro dodge , divide las categorias segun un hue </br> Set context Se puede cambiar el contexto en donde se escala la imagen para adaptarla a nuestra necesidad (paper,talk,notebook,poster) font_scale = 1 , rc = { \"grid.linewidth\" : 5 } In [22]: fig , ax = plt . subplots ( figsize = ( 10 , 10 )) sns . set_context ( \"talk\" ) sns . stripplot ( y = \"edad\" , x = \"Clase\" , data = data , hue = \"Sobreviviente\" ,) plt . show () In [25]: sns . set_context ( \"notebook\" ) sns . stripplot ( y = \"edad\" , x = \"Clase\" , data = data , hue = \"Sobreviviente\" , dodge = True ) plt . show () In [23]: sns . stripplot ( y = data [ \"edad\" ]) Out[23]: <matplotlib.axes._subplots.AxesSubplot at 0x7fdf9ec9ea50> Lm plots Este tipo de graficos es utilizado en regresion y como su nombre nos deja entrever es para graficar modelos lineales. In [24]: sns . lmplot ( x = \"Clase\" , y = \"Tarifa\" , data = data ) Out[24]: <seaborn.axisgrid.FacetGrid at 0x7fdf9edb2490>","tags":"posts","url":"https://c3rssei.github.io/Blog/visualizacion-de-datos.html","loc":"https://c3rssei.github.io/Blog/visualizacion-de-datos.html"},{"title":"Arboles de Decisiones","text":"Descripcion Data Exploration: Es sobre descubrir que es lo que nuestros datos significan estadisticamente y aplicar tecnicas de visualizacion, este paso ser realiza para obtener aspectos importantes del conjunto. Univariado: Se enfoca en el analisis de los atributos uno a uno. Bivariado: Analisa dos atributos en conjunto Si quieres ir directamente a la teoria del arbol de decisiones Go to Aqui! In [1]: #Importacion de librerias import pandas as pd import seaborn as sns import numpy as np import matplotlib.pyplot as plt In [2]: #Cargar los datos data = pd . read_csv ( \"golf-dataset.csv\" ) In [3]: data Out[3]: Outlook Temp Humidity Windy Play Golf 0 Overcast Cool Normal True Yes 1 Overcast Hot High False Yes 2 Overcast Hot Normal False Yes 3 Overcast Mild High True Yes 4 Rainy Cool Normal False Yes 5 Rainy Cool Normal True No 6 Rainy Mild High False Yes 7 Rainy Mild High True No 8 Rainy Mild Normal False Yes 9 Sunny Cool Normal False Yes 10 Sunny Hot High False No 11 Sunny Hot High True No 12 Sunny Mild High False No 13 Sunny Mild Normal True Yes In [4]: #Exploracion de variables para determinar que son, numericas o categoricas data . dtypes Out[4]: Outlook object Temp object Humidity object Windy bool Play Golf object dtype: object In [5]: #Exploracion de variables para determinar si nos enfretamos con registros nulos data . info () <class 'pandas.core.frame.DataFrame'> RangeIndex: 14 entries, 0 to 13 Data columns (total 5 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Outlook 14 non-null object 1 Temp 14 non-null object 2 Humidity 14 non-null object 3 Windy 14 non-null bool 4 Play Golf 14 non-null object dtypes: bool(1), object(4) memory usage: 590.0+ bytes In [6]: #**Exploracion de variables para determinar si nos enfretamos Problemas atipicos y grandes desviaciones** data . describe ( include = \"all\" ) Out[6]: Outlook Temp Humidity Windy Play Golf count 14 14 14 14 14 unique 3 3 2 2 2 top Sunny Mild Normal False Yes freq 5 6 7 8 9 Analisis Univariado Parte del analisis univariado incluye realizar tablas de frecuencia para observar que tan recurrentes son las categorias. Como son atributos categoricos lo unico que podemos hacer es generar graficos pie o bar y tablas de frecuencia. Para realizar la tabla, creo un nuevo dataframe llamado outlook, mediante el metodo group by que agrupa los datos creando un nuevo indice en este caso sera el atributo outlook, mediante agg creamos una nueva columna que almacena el conteo de los atributos. In [7]: outlook = data . groupby ( \"Outlook\" ) . agg ( Frecuencia = ( \"Outlook\" , \"count\" )) outlook [ \"Frecuencia Acumulada\" ] = outlook [ \"Frecuencia\" ] . cumsum () outlook [ \"Frecuencia Relativa\" ] = outlook [ \"Frecuencia\" ] / 14 outlook Out[7]: Frecuencia Frecuencia Acumulada Frecuencia Relativa Outlook Overcast 4 4 0.285714 Rainy 5 9 0.357143 Sunny 5 14 0.357143 In [41]: plt . subplots ( figsize = ( 15 , 15 )) sns . set_palette ( \"hls\" , 8 ) plt . subplot ( 2 , 2 , 1 ) ax = data [ \"Outlook\" ] . value_counts () . plot . pie ( legend = True , autopct = \" %1.1f%% \" ) ax . set ( title = \"Outlook\" , ylabel = \"\" ) plt . subplot ( 2 , 2 , 2 ) sns . countplot ( x = data [ \"Outlook\" ]) Out[41]: <matplotlib.axes._subplots.AxesSubplot at 0x7f38bd8c5b38> In [48]: temp = data . groupby ( \"Temp\" ) . agg ( Frecuencia = ( \"Temp\" , \"count\" )) temp [ \"Frecuencia Absoluta\" ] = temp [ \"Frecuencia\" ] . cumsum () temp [ \"Frecuencia Relativa % \" ] = round (( temp [ \"Frecuencia\" ] / 14 ) * 100 , 2 ) temp Out[48]: Frecuencia Frecuencia Absoluta Frecuencia Relativa % Temp Cool 4 4 28.57 Hot 4 8 28.57 Mild 6 14 42.86 In [51]: plt . subplots ( figsize = ( 10 , 10 )) plt . subplot ( 2 , 2 , 1 ) #Fila,columna, indice data [ \"Temp\" ] . value_counts () . plot . pie ( legend = True , autopct = \" %1.1f%% \" ) plt . subplot ( 2 , 2 , 2 ) sns . countplot ( data [ \"Temp\" ]) Out[51]: <matplotlib.axes._subplots.AxesSubplot at 0x7f38bd547d30> In [54]: humidity = data . groupby ( \"Humidity\" ) . agg ( Frecuencia = ( \"Humidity\" , \"count\" )) humidity [ \"Frecuencia Absotula\" ] = humidity [ \"Frecuencia\" ] . cumsum () humidity [ \"Frecuencia Relativa\" ] = round (( humidity [ \"Frecuencia\" ] / 14 ) * 100 , 2 ) humidity Out[54]: Frecuencia Frecuencia Absotula Frecuencia Relativa Humidity High 7 7 50.0 Normal 7 14 50.0 In [57]: plt . subplots ( figsize = ( 10 , 10 )) plt . subplot ( 2 , 2 , 1 ) #Fila,columna, indice data [ \"Humidity\" ] . value_counts () . plot . pie ( legend = True , autopct = \" %1.1f%% \" ) plt . subplot ( 2 , 2 , 2 ) sns . countplot ( data [ \"Humidity\" ]) Out[57]: <matplotlib.axes._subplots.AxesSubplot at 0x7f38bd51bac8> In [60]: windy = data . groupby ( \"Windy\" ) . agg ( Frecuencia = ( \"Windy\" , \"count\" )) windy [ \"Frecuencia Absoluta\" ] = windy [ \"Frecuencia\" ] . cumsum () windy [ \"Frecuencia Relativa\" ] = round (( windy [ \"Frecuencia\" ] / 14 ) * 100 , 2 ) windy Out[60]: Frecuencia Frecuencia Absoluta Frecuencia Relativa Windy False 8 8 57.14 True 6 14 42.86 In [63]: plt . figure ( figsize = ( 10 , 10 )) plt . subplot ( 2 , 2 , 1 ) windy [ \"Frecuencia\" ] . plot . pie ( legend = True , autopct = \" %1.1f%% \" ) plt . subplot ( 2 , 2 , 2 ) sns . barplot ( windy . index , windy [ \"Frecuencia\" ]) Out[63]: <matplotlib.axes._subplots.AxesSubplot at 0x7f38bcf573c8> Analisis Bivariado Consiste en el analisis simultaneo de dos variables, explora el concepto de relacion entre las variables (predictor vs target) , Existen tres tipos de analisis Bivariado Numerico & Numerico Categorico & Categorico Numerico & Categorico En el caso de mi dataset es categorico vs categorico , lo que esta compuesto por graficos de barras y el test de chi cuadrado. Para este tipo de analisis chi cuadrado se generan dos hipotesis: hipotesis nula : jugar o no jugar *No* depende del outlook/ wind / humidity/ temp hipotesis alternativa : jugar o no jugar depende del outlook/ wind / humidity/ temp In [66]: pd . crosstab ( data [ \"Outlook\" ], data [ \"Play Golf\" ], margins = True ) Out[66]: Play Golf No Yes All Outlook Overcast 0 4 4 Rainy 2 3 5 Sunny 3 2 5 All 5 9 14 In [69]: plt . figure ( figsize = ( 5 , 5 )) g = sns . countplot ( x = \"Temp\" , data = data , hue = \"Play Golf\" ) In [72]: g = sns . countplot ( x = \"Outlook\" , data = data , hue = \"Play Golf\" ) In [75]: g = sns . countplot ( x = \"Humidity\" , data = data , hue = \"Play Golf\" ) In [78]: g = sns . countplot ( x = \"Windy\" , data = data , hue = \"Play Golf\" ) Test de chi2 para determinar la asociacion entre los atributos(Categoria) Manualmente chicuadrado se calcula con tres pasos: Definir las hipotesis --> listo Construir Tabla de Contingencia Calcular valor de chi cuadrado Tabla de Contingencia La tabla de contingencia se construye con la siguiente formula $E = n * P$ n: Cantidad de elementos en el subconjunto P: Probabilidad la tabla de contingencia se construye en base a la tabla de observados de la siguiente manera: In [81]: observado = pd . crosstab ( data [ \"Outlook\" ], data [ \"Play Golf\" ], margins = True ) print ( observado ) #e1 = 14*((observado[\"All\"][\"Overcast\"]/14 )*(observado[\"Yes\"][\"All\"]/14)) Play Golf No Yes All Outlook Overcast 0 4 4 Rainy 2 3 5 Sunny 3 2 5 All 5 9 14 La tabla de contigencia se construye de la siguiente manera: Tabla de contigencia Play Golf No Yes Overcast E1 = 14 x p(overcast|no) = 14 * p(overcast)* p(no) = 14 * (4/14)* (5/14) = 1.42 E2 = 14 x p(overcast|yes) = 14 * p(overcast)* p(yes) = 14 * (4/14)* (9/14) = 2.57 Rainy E3 = 14 x p(rainy|no) = 14 * p(rainy)* p(no) = 14 * (5/14)* (5/14) = 1.78 E4 = 14 x p(rainy|yes) = 14 * p(rainy)* p(yes) = 14 * (5/14)* (9/14) = 3.12 Sunny E5 = 14 x p(sunny|no) = 14 * p(sunny)* p(no) = 14 * (5/14)* (5/14) = 1.78 E6 = 14 x p(sunny|yes) = 14 * p(sunny)* p(no) = 14 * (5/14)* (9/14) = 3.12 Calcular Chi cuadrado $\\sum{(E-O)**2/E}$ overcast|no = (0- E1)** 2/E1 = (0-1.42)** 2/1.42 = 2.86 overcast|yes = (4 - 2.57)**2/2.57= 5.25 rainy|no =(2-1.78)**2/1.78 = 0.086 rainy|yes=(3-3.12)**2/3.12 = 0.044 sunny|no=(3-1.78)**2/1.78=2.64 sunny|yes=(2-3.12)**2/3.12=3.91 $\\sum{(E-O)**2/E}$ = 14.79 Teniendo en consideracion un alpha de 0.05 ; $df = (nºfilas-1)(nºcolumnas-1)$ df=3-1 * 2-1 = 2 busco el valor en la tabla de chi cuadrado Link Tabla chi=5.99 como el corte de la region es en el punto 5.99 el valor 14.79 cae fuera de la region de aceptacion de h0 entonces aceptamos la hiptesis alternativa que indica que existe relacion entre el target y outlook. Scipy proporciona un metodo que realiza esto y es de la siguiente manera In [84]: from scipy.stats import chi2_contingency observado = pd . crosstab ( data [ \"Outlook\" ], data [ \"Play Golf\" ]) chi , pvalue , df , expected = chi2_contingency ( observado ) print ( \"Outlook vs Play Golf \\n \" ) print ( \"valor de chi cuadrado :\" , chi ) print ( \"valor p o punto de corte:\" , pvalue ) print ( \"grados de libertad:\" , df ) print ( \"\" ) print ( \"Tabla de contingencia \\n \" , expected ) Outlook vs Play Golf valor de chi cuadrado : 3.5466666666666664 valor p o punto de corte: 0.16976615743981122 grados de libertad: 2 Tabla de contingencia [[1.42857143 2.57142857] [1.78571429 3.21428571] [1.78571429 3.21428571]] In [87]: observado = pd . crosstab ( data [ \"Temp\" ], data [ \"Play Golf\" ]) chi , pvalue , df , expected = chi2_contingency ( observado ) print ( \"Temp vs Play Golf \\n \" ) print ( \"valor de chi cuadrado :\" , chi ) print ( \"valor p o punto de corte:\" , pvalue ) print ( \"grados de libertad:\" , df ) print ( \"\" ) print ( \"Tabla de contingencia \\n \" , expected ) Temp vs Play Golf valor de chi cuadrado : 0.5703703703703703 valor p o punto de corte: 0.7518750053142591 grados de libertad: 2 Tabla de contingencia [[1.42857143 2.57142857] [1.42857143 2.57142857] [2.14285714 3.85714286]] In [90]: observado = pd . crosstab ( data [ \"Humidity\" ], data [ \"Play Golf\" ]) chi , pvalue , df , expected = chi2_contingency ( observado ) print ( \"Humidity vs Play Golf \\n \" ) print ( \"valor de chi cuadrado :\" , chi ) print ( \"valor p o punto de corte:\" , pvalue ) Humidity vs Play Golf valor de chi cuadrado : 1.2444444444444445 valor p o punto de corte: 0.2646162170835855 In [93]: observado = pd . crosstab ( data [ \"Windy\" ], data [ \"Play Golf\" ]) chi , pvalue , df , expected = chi2_contingency ( observado ) print ( \"Windy vs Play Golf \\n \" ) print ( \"valor de chi cuadrado :\" , chi ) print ( \"valor p o punto de corte:\" , pvalue ) Windy vs Play Golf valor de chi cuadrado : 0.16203703703703703 valor p o punto de corte: 0.687287949348002 Resumen Outlook vs Play Golf Se acepta la Hipotesis Alternativa Temp vs Play Golf Se acepta la Hipotesis nula Humidity vs Play Golf Se acepta la Hipotesis alternativa Windy vs Play Gol Se acepta la Hipotesis nulaf Predecir el futuro Esta parte lo que hace es predicir el futuro mediante el modelamiento, como el target es categorico entonces nos enfrentamos a un problema de clasificacion si el target hubiese sido numerico entonces seria regression Arbol de decision Los arboles de decision son modelos con estructura de arbol, el resultado final es un arbol con nodos de decision y nodos hoja. Existen varios algoritmos que permiten la construccion de un arbol de decisiones yo ocupare ID3 que emplea dos principales formulas matematicas Entropia y information gain . La entropia nos permite calcular la homogeneidad de la muestra, varia de o - 1, mientras mas cercano sea a 1 mas variado sera nuestro conjunto viceversa si es mas cercano a 0 sera mas homogeneo. Entropia del target. E(y) = $\\sum{(-P(Ci)* (log(P(Ci))/log 2)}$ Entropia de los predictores. E(Y,x) = $\\sum{(P(Ci)* E(Ci)}$ In [96]: #Entropia del target #Tabla auxiliar import math golf = data . groupby ( \"Play Golf\" ) . agg ( Frecuencia = ( \"Play Golf\" , \"count\" )) golf E_golf = 0 for i in golf [ \"Frecuencia\" ]: E_golf = E_golf - i / 14 * math . log ( i / 14 , 2 ) print ( \"Entropia Y = \" , round ( E_golf , 2 )) #E_golf = -golf[\"Frecuencia\"]/14*math.log(golf[\"Frecuencia\"],2) Entropia Y = 0.94 In [143]: outlook = pd . crosstab ( data [ \"Outlook\" ], data [ \"Play Golf\" ], margins = True ) #E_golf_outlook = -outlook[\"All\"]/14 +(math.log(outlook[\"Yes\"]/outlook[\"All\"],2) + math.log(outlook[\"No\"]/outlook[\"All\"],2)) labels = set ( list ( data [ \"Outlook\" ])) def Entropia_pred ( observados ): E = 0 aux = 0 for i in labels : if observados [ \"Yes\" ][ i ] == 0 : a = 0 else : a = math . log2 ( float ( observados [ \"Yes\" ][ i ] / observados [ \"All\" ][ i ])) if observados [ \"No\" ][ i ] == 0 : b = 0 else : b = math . log2 ( float ( observados [ \"No\" ][ i ] / observados [ \"All\" ][ i ])) aux = ( observados [ \"All\" ][ i ] / 14 ) * (( - observados [ \"Yes\" ][ i ] / observados [ \"All\" ][ i ] ) * a - ( observados [ \"No\" ][ i ] / observados [ \"All\" ][ i ]) * b ) E = E + aux print ( \"Entropia de Outlook\" , E ) Entropia_pred ( outlook ) Entropia de Outlook 0.6935361388961918 In [102]: temp = pd . crosstab ( data [ \"Temp\" ], data [ \"Play Golf\" ], margins = True ) labels = set ( list ( data [ \"Temp\" ])) Entropia_pred ( temp ) Entropia de Outlook 0.9110633930116763 In [105]: hum = pd . crosstab ( data [ \"Humidity\" ], data [ \"Play Golf\" ], margins = True ) labels = set ( list ( data [ \"Humidity\" ])) Entropia_pred ( hum ) Entropia de Outlook 0.7884504573082896 In [108]: wind = pd . crosstab ( data [ \"Windy\" ], data [ \"Play Golf\" ], margins = True ) labels = set ( list ( data [ \"Windy\" ])) Entropia_pred ( wind ) Entropia de Outlook 0.8921589282623617 Una vez calculadas las entropias se procede a calcular el gain $Information Gain(Y,x)=E(Y)-E(x)$ gain(play golf, Outlook)= E(Play Golf) - E(Play Golf,Outlook) = 0.94 - 0.69 = 0.25 gain(Play Golf,Temp) = 0.94 - 0.73 =0.21 gain(Play Golf, Humidity) = 0.94 - 0.788 =0.15 gain(Play Golf, Windy) = 0.94 - 0.89 =0.05 El gain mas alto corresponde al nodo raiz por ende sera Outlook, ahora filtramos la data por cada una de las categorias de outlook y las trabajamos a parte para encontrar el nodo que viene de la misma manera que lo habiamos hecho In [111]: filter = data [ data [ \"Outlook\" ] == \"Sunny\" ] temp = pd . crosstab ( filter [ \"Temp\" ], filter [ \"Play Golf\" ], margins = True ) labels = set ( list ( data [ \"Temp\" ])) Entropia_pred ( temp ) Entropia de Outlook 0.14285714285714285 In [114]: hum = pd . crosstab ( filter [ \"Humidity\" ], filter [ \"Play Golf\" ], margins = True ) labels = set ( list ( data [ \"Humidity\" ])) Entropia_pred ( hum ) Entropia de Outlook 0.0 In [117]: wind = pd . crosstab ( filter [ \"Windy\" ], filter [ \"Play Golf\" ], margins = True ) labels = set ( list ( data [ \"Windy\" ])) Entropia_pred ( wind ) Entropia de Outlook 0.3396348215831049 otra vez el gain para determinar que nodo se ubicara despues de outlook == Sunny gain(Play Gol outlook=Sunny,temp) =0.97 - 0.14 gain(Play Golf outlook=Sunny,Windy) = 0.97 - 0.33 gain(Play Golf outlook=Sunny,Humidity) = 0.97 - 0 = 0.97 Entonces el ganador es Humidity In [144]: filtro = data [ data [ \"Outlook\" ] == \"Rainy\" ] temp = pd . crosstab ( filtro [ \"Temp\" ], filtro [ \"Play Golf\" ], margins = True ) labels = set ( list ( filtro [ \"Temp\" ])) Entropia_pred ( temp ) Entropia de Outlook 0.3396348215831049 In [145]: filtro = data [ data [ \"Outlook\" ] == \"Rainy\" ] wind = pd . crosstab ( filtro [ \"Windy\" ], filtro [ \"Play Golf\" ], margins = True ) labels = set ( list ( filtro [ \"Windy\" ])) Entropia_pred ( wind ) Entropia de Outlook 0.0 Entonces calcular el gain seria: Gain(Play Golf Outlook =\"Rainy\", Temp) = 0.97 - 0.95 Gain(Play Golf Outlook =\"Rainy\", Windy) = 0.97 - 0 Dejamos como nodo Windy In [126]: outlook = pd . crosstab ( data [ \"Windy\" ], data [ \"Play Golf\" ]) aux = [] for i in outlook . values : aux . append ( i [ 0 ] + i [ 1 ]) In [129]: outlook [ \"Frecuencia\" ] = aux outlook Out[129]: Play Golf No Yes Frecuencia Windy False 2 6 8 True 3 3 6","tags":"posts","url":"https://c3rssei.github.io/Blog/arboles-de-decisiones.html","loc":"https://c3rssei.github.io/Blog/arboles-de-decisiones.html"}]};